˝0lT]·ÜÉêcíﬁ=AÇÿ©›Y~NÇÛZaHTTP/2.0 200 OK
Content-Length: 899981
Accept-Ranges: bytes
Audit-Id: 185949f6-80be-4144-861b-dfa1086b0c21
Cache-Control: public, immutable
Content-Type: application/json
Date: Mon, 31 Jul 2023 11:04:01 GMT
Etag: "AD47F0C5824CECBD7314D42DA8D96D5367593FB867ECC21EB3B940A0C7179B1565A44C70249A5CBAF3985E92F27489593DD1CDB58CE3CD623F9E5366712BD37C"
Expires: Wed, 31 Jul 2024 11:04:01 UTC
Last-Modified: Mon, 31 Jul 2023 11:02:00 GMT
Vary: Accept
X-Kubernetes-Pf-Flowschema-Uid: 499090c7-f609-4794-a535-f71628312ce1
X-Kubernetes-Pf-Prioritylevel-Uid: df3d59bd-c9b6-4324-9328-71dc0804503b
X-Varied-Accept: application/json

{"openapi":"3.0.0","info":{"title":"Kubernetes CRD Swagger","version":"v0.1.0"},"paths":{"/apis/kafka.strimzi.io/v1beta2/kafkabridges":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaBridge","operationId":"listKafkaStrimziIoV1beta2KafkaBridgeForAllNamespaces","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridgeList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridgeList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaBridge"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/kafkaconnectors":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaConnector","operationId":"listKafkaStrimziIoV1beta2KafkaConnectorForAllNamespaces","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnectorList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnectorList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnector"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/kafkaconnects":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaConnect","operationId":"listKafkaStrimziIoV1beta2KafkaConnectForAllNamespaces","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnectList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnectList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnect"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/kafkamirrormaker2s":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaMirrorMaker2","operationId":"listKafkaStrimziIoV1beta2KafkaMirrorMaker2ForAllNamespaces","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2List"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2List"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker2"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/kafkamirrormakers":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaMirrorMaker","operationId":"listKafkaStrimziIoV1beta2KafkaMirrorMakerForAllNamespaces","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMakerList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMakerList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/kafkanodepools":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaNodePool","operationId":"listKafkaStrimziIoV1beta2KafkaNodePoolForAllNamespaces","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePoolList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePoolList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaNodePool"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/kafkarebalances":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaRebalance","operationId":"listKafkaStrimziIoV1beta2KafkaRebalanceForAllNamespaces","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalanceList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalanceList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaRebalance"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/kafkas":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind Kafka","operationId":"listKafkaStrimziIoV1beta2KafkaForAllNamespaces","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"Kafka"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/kafkatopics":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaTopic","operationId":"listKafkaStrimziIoV1beta2KafkaTopicForAllNamespaces","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopicList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopicList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaTopic"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/kafkausers":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaUser","operationId":"listKafkaStrimziIoV1beta2KafkaUserForAllNamespaces","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUserList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUserList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaUser"}},"parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkabridges":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaBridge","operationId":"listKafkaStrimziIoV1beta2NamespacedKafkaBridge","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridgeList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridgeList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaBridge"}},"post":{"tags":["kafkaStrimziIo_v1beta2"],"description":"create a KafkaBridge","operationId":"createKafkaStrimziIoV1beta2NamespacedKafkaBridge","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"post","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaBridge"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete collection of KafkaBridge","operationId":"deleteKafkaStrimziIoV1beta2CollectionNamespacedKafkaBridge","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"deletecollection","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaBridge"}},"parameters":[{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkabridges/{name}":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read the specified KafkaBridge","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaBridge","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaBridge"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace the specified KafkaBridge","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaBridge","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaBridge"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete a KafkaBridge","operationId":"deleteKafkaStrimziIoV1beta2NamespacedKafkaBridge","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"gracePeriodSeconds","in":"query","description":"The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.","schema":{"type":"integer","uniqueItems":true}},{"name":"orphanDependents","in":"query","description":"Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.","schema":{"type":"boolean","uniqueItems":true}},{"name":"propagationPolicy","in":"query","description":"Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"delete","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaBridge"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update the specified KafkaBridge","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaBridge","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaBridge"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaBridge","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkabridges/{name}/scale":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read scale of the specified KafkaBridge","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaBridgeScale","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaBridge"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace scale of the specified KafkaBridge","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaBridgeScale","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaBridge"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update scale of the specified KafkaBridge","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaBridgeScale","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaBridge"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaBridge","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkabridges/{name}/status":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read status of the specified KafkaBridge","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaBridgeStatus","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaBridge"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace status of the specified KafkaBridge","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaBridgeStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaBridge"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update status of the specified KafkaBridge","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaBridgeStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaBridge"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaBridge","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkaconnectors":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaConnector","operationId":"listKafkaStrimziIoV1beta2NamespacedKafkaConnector","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnectorList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnectorList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnector"}},"post":{"tags":["kafkaStrimziIo_v1beta2"],"description":"create a KafkaConnector","operationId":"createKafkaStrimziIoV1beta2NamespacedKafkaConnector","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"post","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnector"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete collection of KafkaConnector","operationId":"deleteKafkaStrimziIoV1beta2CollectionNamespacedKafkaConnector","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"deletecollection","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnector"}},"parameters":[{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkaconnectors/{name}":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read the specified KafkaConnector","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaConnector","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnector"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace the specified KafkaConnector","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaConnector","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnector"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete a KafkaConnector","operationId":"deleteKafkaStrimziIoV1beta2NamespacedKafkaConnector","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"gracePeriodSeconds","in":"query","description":"The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.","schema":{"type":"integer","uniqueItems":true}},{"name":"orphanDependents","in":"query","description":"Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.","schema":{"type":"boolean","uniqueItems":true}},{"name":"propagationPolicy","in":"query","description":"Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"delete","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnector"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update the specified KafkaConnector","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaConnector","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnector"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaConnector","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkaconnectors/{name}/scale":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read scale of the specified KafkaConnector","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaConnectorScale","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnector"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace scale of the specified KafkaConnector","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaConnectorScale","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnector"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update scale of the specified KafkaConnector","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaConnectorScale","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnector"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaConnector","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkaconnectors/{name}/status":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read status of the specified KafkaConnector","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaConnectorStatus","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnector"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace status of the specified KafkaConnector","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaConnectorStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnector"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update status of the specified KafkaConnector","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaConnectorStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnector"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaConnector","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkaconnects":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaConnect","operationId":"listKafkaStrimziIoV1beta2NamespacedKafkaConnect","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnectList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnectList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnect"}},"post":{"tags":["kafkaStrimziIo_v1beta2"],"description":"create a KafkaConnect","operationId":"createKafkaStrimziIoV1beta2NamespacedKafkaConnect","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"post","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnect"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete collection of KafkaConnect","operationId":"deleteKafkaStrimziIoV1beta2CollectionNamespacedKafkaConnect","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"deletecollection","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnect"}},"parameters":[{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkaconnects/{name}":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read the specified KafkaConnect","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaConnect","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnect"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace the specified KafkaConnect","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaConnect","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnect"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete a KafkaConnect","operationId":"deleteKafkaStrimziIoV1beta2NamespacedKafkaConnect","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"gracePeriodSeconds","in":"query","description":"The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.","schema":{"type":"integer","uniqueItems":true}},{"name":"orphanDependents","in":"query","description":"Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.","schema":{"type":"boolean","uniqueItems":true}},{"name":"propagationPolicy","in":"query","description":"Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"delete","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnect"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update the specified KafkaConnect","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaConnect","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnect"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaConnect","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkaconnects/{name}/scale":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read scale of the specified KafkaConnect","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaConnectScale","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnect"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace scale of the specified KafkaConnect","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaConnectScale","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnect"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update scale of the specified KafkaConnect","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaConnectScale","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnect"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaConnect","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkaconnects/{name}/status":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read status of the specified KafkaConnect","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaConnectStatus","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnect"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace status of the specified KafkaConnect","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaConnectStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnect"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update status of the specified KafkaConnect","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaConnectStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaConnect"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaConnect","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkamirrormaker2s":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaMirrorMaker2","operationId":"listKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker2","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2List"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2List"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker2"}},"post":{"tags":["kafkaStrimziIo_v1beta2"],"description":"create a KafkaMirrorMaker2","operationId":"createKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker2","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"post","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker2"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete collection of KafkaMirrorMaker2","operationId":"deleteKafkaStrimziIoV1beta2CollectionNamespacedKafkaMirrorMaker2","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"deletecollection","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker2"}},"parameters":[{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkamirrormaker2s/{name}":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read the specified KafkaMirrorMaker2","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker2","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker2"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace the specified KafkaMirrorMaker2","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker2","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker2"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete a KafkaMirrorMaker2","operationId":"deleteKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker2","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"gracePeriodSeconds","in":"query","description":"The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.","schema":{"type":"integer","uniqueItems":true}},{"name":"orphanDependents","in":"query","description":"Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.","schema":{"type":"boolean","uniqueItems":true}},{"name":"propagationPolicy","in":"query","description":"Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"delete","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker2"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update the specified KafkaMirrorMaker2","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker2","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker2"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaMirrorMaker2","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkamirrormaker2s/{name}/scale":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read scale of the specified KafkaMirrorMaker2","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker2Scale","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker2"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace scale of the specified KafkaMirrorMaker2","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker2Scale","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker2"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update scale of the specified KafkaMirrorMaker2","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker2Scale","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker2"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaMirrorMaker2","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkamirrormaker2s/{name}/status":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read status of the specified KafkaMirrorMaker2","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker2Status","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker2"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace status of the specified KafkaMirrorMaker2","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker2Status","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker2"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update status of the specified KafkaMirrorMaker2","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker2Status","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker2"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaMirrorMaker2","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkamirrormakers":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaMirrorMaker","operationId":"listKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMakerList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMakerList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker"}},"post":{"tags":["kafkaStrimziIo_v1beta2"],"description":"create a KafkaMirrorMaker","operationId":"createKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"post","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete collection of KafkaMirrorMaker","operationId":"deleteKafkaStrimziIoV1beta2CollectionNamespacedKafkaMirrorMaker","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"deletecollection","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker"}},"parameters":[{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkamirrormakers/{name}":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read the specified KafkaMirrorMaker","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace the specified KafkaMirrorMaker","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete a KafkaMirrorMaker","operationId":"deleteKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"gracePeriodSeconds","in":"query","description":"The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.","schema":{"type":"integer","uniqueItems":true}},{"name":"orphanDependents","in":"query","description":"Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.","schema":{"type":"boolean","uniqueItems":true}},{"name":"propagationPolicy","in":"query","description":"Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"delete","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update the specified KafkaMirrorMaker","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaMirrorMaker","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaMirrorMaker","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkamirrormakers/{name}/scale":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read scale of the specified KafkaMirrorMaker","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaMirrorMakerScale","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace scale of the specified KafkaMirrorMaker","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaMirrorMakerScale","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update scale of the specified KafkaMirrorMaker","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaMirrorMakerScale","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaMirrorMaker","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkamirrormakers/{name}/status":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read status of the specified KafkaMirrorMaker","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaMirrorMakerStatus","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace status of the specified KafkaMirrorMaker","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaMirrorMakerStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update status of the specified KafkaMirrorMaker","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaMirrorMakerStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaMirrorMaker"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaMirrorMaker","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkanodepools":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaNodePool","operationId":"listKafkaStrimziIoV1beta2NamespacedKafkaNodePool","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePoolList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePoolList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaNodePool"}},"post":{"tags":["kafkaStrimziIo_v1beta2"],"description":"create a KafkaNodePool","operationId":"createKafkaStrimziIoV1beta2NamespacedKafkaNodePool","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"post","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaNodePool"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete collection of KafkaNodePool","operationId":"deleteKafkaStrimziIoV1beta2CollectionNamespacedKafkaNodePool","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"deletecollection","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaNodePool"}},"parameters":[{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkanodepools/{name}":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read the specified KafkaNodePool","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaNodePool","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaNodePool"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace the specified KafkaNodePool","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaNodePool","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaNodePool"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete a KafkaNodePool","operationId":"deleteKafkaStrimziIoV1beta2NamespacedKafkaNodePool","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"gracePeriodSeconds","in":"query","description":"The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.","schema":{"type":"integer","uniqueItems":true}},{"name":"orphanDependents","in":"query","description":"Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.","schema":{"type":"boolean","uniqueItems":true}},{"name":"propagationPolicy","in":"query","description":"Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"delete","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaNodePool"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update the specified KafkaNodePool","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaNodePool","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaNodePool"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaNodePool","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkanodepools/{name}/scale":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read scale of the specified KafkaNodePool","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaNodePoolScale","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaNodePool"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace scale of the specified KafkaNodePool","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaNodePoolScale","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaNodePool"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update scale of the specified KafkaNodePool","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaNodePoolScale","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.Scale"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaNodePool"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaNodePool","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkanodepools/{name}/status":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read status of the specified KafkaNodePool","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaNodePoolStatus","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaNodePool"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace status of the specified KafkaNodePool","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaNodePoolStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaNodePool"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update status of the specified KafkaNodePool","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaNodePoolStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaNodePool"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaNodePool","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkarebalances":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaRebalance","operationId":"listKafkaStrimziIoV1beta2NamespacedKafkaRebalance","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalanceList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalanceList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaRebalance"}},"post":{"tags":["kafkaStrimziIo_v1beta2"],"description":"create a KafkaRebalance","operationId":"createKafkaStrimziIoV1beta2NamespacedKafkaRebalance","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"post","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaRebalance"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete collection of KafkaRebalance","operationId":"deleteKafkaStrimziIoV1beta2CollectionNamespacedKafkaRebalance","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"deletecollection","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaRebalance"}},"parameters":[{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkarebalances/{name}":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read the specified KafkaRebalance","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaRebalance","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaRebalance"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace the specified KafkaRebalance","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaRebalance","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaRebalance"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete a KafkaRebalance","operationId":"deleteKafkaStrimziIoV1beta2NamespacedKafkaRebalance","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"gracePeriodSeconds","in":"query","description":"The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.","schema":{"type":"integer","uniqueItems":true}},{"name":"orphanDependents","in":"query","description":"Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.","schema":{"type":"boolean","uniqueItems":true}},{"name":"propagationPolicy","in":"query","description":"Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"delete","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaRebalance"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update the specified KafkaRebalance","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaRebalance","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaRebalance"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaRebalance","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkarebalances/{name}/status":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read status of the specified KafkaRebalance","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaRebalanceStatus","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaRebalance"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace status of the specified KafkaRebalance","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaRebalanceStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaRebalance"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update status of the specified KafkaRebalance","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaRebalanceStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaRebalance"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaRebalance","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkas":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind Kafka","operationId":"listKafkaStrimziIoV1beta2NamespacedKafka","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"Kafka"}},"post":{"tags":["kafkaStrimziIo_v1beta2"],"description":"create a Kafka","operationId":"createKafkaStrimziIoV1beta2NamespacedKafka","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"post","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"Kafka"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete collection of Kafka","operationId":"deleteKafkaStrimziIoV1beta2CollectionNamespacedKafka","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"deletecollection","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"Kafka"}},"parameters":[{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkas/{name}":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read the specified Kafka","operationId":"readKafkaStrimziIoV1beta2NamespacedKafka","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"Kafka"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace the specified Kafka","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafka","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"Kafka"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete a Kafka","operationId":"deleteKafkaStrimziIoV1beta2NamespacedKafka","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"gracePeriodSeconds","in":"query","description":"The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.","schema":{"type":"integer","uniqueItems":true}},{"name":"orphanDependents","in":"query","description":"Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.","schema":{"type":"boolean","uniqueItems":true}},{"name":"propagationPolicy","in":"query","description":"Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"delete","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"Kafka"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update the specified Kafka","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafka","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"Kafka"}},"parameters":[{"name":"name","in":"path","description":"name of the Kafka","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkas/{name}/status":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read status of the specified Kafka","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaStatus","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"Kafka"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace status of the specified Kafka","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"Kafka"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update status of the specified Kafka","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"Kafka"}},"parameters":[{"name":"name","in":"path","description":"name of the Kafka","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkatopics":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaTopic","operationId":"listKafkaStrimziIoV1beta2NamespacedKafkaTopic","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopicList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopicList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaTopic"}},"post":{"tags":["kafkaStrimziIo_v1beta2"],"description":"create a KafkaTopic","operationId":"createKafkaStrimziIoV1beta2NamespacedKafkaTopic","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"post","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaTopic"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete collection of KafkaTopic","operationId":"deleteKafkaStrimziIoV1beta2CollectionNamespacedKafkaTopic","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"deletecollection","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaTopic"}},"parameters":[{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkatopics/{name}":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read the specified KafkaTopic","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaTopic","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaTopic"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace the specified KafkaTopic","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaTopic","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaTopic"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete a KafkaTopic","operationId":"deleteKafkaStrimziIoV1beta2NamespacedKafkaTopic","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"gracePeriodSeconds","in":"query","description":"The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.","schema":{"type":"integer","uniqueItems":true}},{"name":"orphanDependents","in":"query","description":"Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.","schema":{"type":"boolean","uniqueItems":true}},{"name":"propagationPolicy","in":"query","description":"Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"delete","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaTopic"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update the specified KafkaTopic","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaTopic","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaTopic"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaTopic","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkatopics/{name}/status":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read status of the specified KafkaTopic","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaTopicStatus","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaTopic"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace status of the specified KafkaTopic","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaTopicStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaTopic"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update status of the specified KafkaTopic","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaTopicStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaTopic"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaTopic","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkausers":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"list objects of kind KafkaUser","operationId":"listKafkaStrimziIoV1beta2NamespacedKafkaUser","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUserList"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUserList"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"list","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaUser"}},"post":{"tags":["kafkaStrimziIo_v1beta2"],"description":"create a KafkaUser","operationId":"createKafkaStrimziIoV1beta2NamespacedKafkaUser","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"post","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaUser"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete collection of KafkaUser","operationId":"deleteKafkaStrimziIoV1beta2CollectionNamespacedKafkaUser","parameters":[{"name":"allowWatchBookmarks","in":"query","description":"allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.","schema":{"type":"boolean","uniqueItems":true}},{"name":"continue","in":"query","description":"The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldSelector","in":"query","description":"A selector to restrict the list of returned objects by their fields. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"labelSelector","in":"query","description":"A selector to restrict the list of returned objects by their labels. Defaults to everything.","schema":{"type":"string","uniqueItems":true}},{"name":"limit","in":"query","description":"limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.","schema":{"type":"integer","uniqueItems":true}},{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"resourceVersionMatch","in":"query","description":"resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}},{"name":"sendInitialEvents","in":"query","description":"`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.","schema":{"type":"boolean","uniqueItems":true}},{"name":"timeoutSeconds","in":"query","description":"Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.","schema":{"type":"integer","uniqueItems":true}},{"name":"watch","in":"query","description":"Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.","schema":{"type":"boolean","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"deletecollection","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaUser"}},"parameters":[{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkausers/{name}":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read the specified KafkaUser","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaUser","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaUser"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace the specified KafkaUser","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaUser","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaUser"}},"delete":{"tags":["kafkaStrimziIo_v1beta2"],"description":"delete a KafkaUser","operationId":"deleteKafkaStrimziIoV1beta2NamespacedKafkaUser","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"gracePeriodSeconds","in":"query","description":"The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.","schema":{"type":"integer","uniqueItems":true}},{"name":"orphanDependents","in":"query","description":"Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.","schema":{"type":"boolean","uniqueItems":true}},{"name":"propagationPolicy","in":"query","description":"Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"202":{"description":"Accepted","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"delete","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaUser"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update the specified KafkaUser","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaUser","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaUser"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaUser","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]},"/apis/kafka.strimzi.io/v1beta2/namespaces/{namespace}/kafkausers/{name}/status":{"get":{"tags":["kafkaStrimziIo_v1beta2"],"description":"read status of the specified KafkaUser","operationId":"readKafkaStrimziIoV1beta2NamespacedKafkaUserStatus","parameters":[{"name":"resourceVersion","in":"query","description":"resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset","schema":{"type":"string","uniqueItems":true}}],"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"get","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaUser"}},"put":{"tags":["kafkaStrimziIo_v1beta2"],"description":"replace status of the specified KafkaUser","operationId":"replaceKafkaStrimziIoV1beta2NamespacedKafkaUserStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}}}},"201":{"description":"Created","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"put","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaUser"}},"patch":{"tags":["kafkaStrimziIo_v1beta2"],"description":"partially update status of the specified KafkaUser","operationId":"patchKafkaStrimziIoV1beta2NamespacedKafkaUserStatus","parameters":[{"name":"dryRun","in":"query","description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","schema":{"type":"string","uniqueItems":true}},{"name":"fieldManager","in":"query","description":"fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).","schema":{"type":"string","uniqueItems":true}},{"name":"fieldValidation","in":"query","description":"fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.","schema":{"type":"string","uniqueItems":true}},{"name":"force","in":"query","description":"Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.","schema":{"type":"boolean","uniqueItems":true}}],"requestBody":{"content":{"application/apply-patch+yaml":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/json-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}},"application/merge-patch+json":{"schema":{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"}}}},"responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}},"application/yaml":{"schema":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}}}},"401":{"description":"Unauthorized"}},"x-kubernetes-action":"patch","x-kubernetes-group-version-kind":{"group":"kafka.strimzi.io","version":"v1beta2","kind":"KafkaUser"}},"parameters":[{"name":"name","in":"path","description":"name of the KafkaUser","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"namespace","in":"path","description":"object name and auth scope, such as for teams and projects","required":true,"schema":{"type":"string","uniqueItems":true}},{"name":"pretty","in":"query","description":"If 'true', then the output is pretty printed.","schema":{"type":"string","uniqueItems":true}}]}},"components":{"schemas":{"io.k8s.api.autoscaling.v1.Scale":{"description":"Scale represents a scaling request for a resource.","type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"}]},"spec":{"description":"spec defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status.","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.ScaleSpec"}]},"status":{"description":"status is the current status of the scale. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status. Read-only.","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.api.autoscaling.v1.ScaleStatus"}]}}},"io.k8s.api.autoscaling.v1.ScaleSpec":{"description":"ScaleSpec describes the attributes of a scale subresource.","type":"object","properties":{"replicas":{"description":"replicas is the desired number of instances for the scaled object.","type":"integer","format":"int32"}}},"io.k8s.api.autoscaling.v1.ScaleStatus":{"description":"ScaleStatus represents the current status of a scale subresource.","type":"object","required":["replicas"],"properties":{"replicas":{"description":"replicas is the actual number of observed instances of the scaled object.","type":"integer","format":"int32","default":0},"selector":{"description":"selector is the label query over pods that should match the replicas count. This is same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/","type":"string"}}},"io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions":{"description":"DeleteOptions may be provided when deleting an API object.","type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"dryRun":{"description":"When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed","type":"array","items":{"type":"string","default":""}},"gracePeriodSeconds":{"description":"The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.","type":"integer","format":"int64"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"orphanDependents":{"description":"Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.","type":"boolean"},"preconditions":{"description":"Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be returned.","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Preconditions"}]},"propagationPolicy":{"description":"Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.","type":"string"}}},"io.k8s.apimachinery.pkg.apis.meta.v1.FieldsV1":{"description":"FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.\n\nEach key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:\u003cname\u003e', where \u003cname\u003e is the name of a field in a struct, or key in a map 'v:\u003cvalue\u003e', where \u003cvalue\u003e is the exact json formatted value of a list item 'i:\u003cindex\u003e', where \u003cindex\u003e is position of a item in a list 'k:\u003ckeys\u003e', where \u003ckeys\u003e is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.\n\nThe exact format is defined in sigs.k8s.io/structured-merge-diff","type":"object"},"io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta":{"description":"ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.","type":"object","properties":{"continue":{"description":"continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.","type":"string"},"remainingItemCount":{"description":"remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.","type":"integer","format":"int64"},"resourceVersion":{"description":"String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency","type":"string"},"selfLink":{"description":"Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.","type":"string"}}},"io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry":{"description":"ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.","type":"object","properties":{"apiVersion":{"description":"APIVersion defines the version of this resource that this field set applies to. The format is \"group/version\" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.","type":"string"},"fieldsType":{"description":"FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: \"FieldsV1\"","type":"string"},"fieldsV1":{"description":"FieldsV1 holds the first JSON version format as described in the \"FieldsV1\" type.","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.FieldsV1"}]},"manager":{"description":"Manager is an identifier of the workflow managing these fields.","type":"string"},"operation":{"description":"Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.","type":"string"},"subresource":{"description":"Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.","type":"string"},"time":{"description":"Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over.","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"}]}}},"io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta":{"description":"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.","type":"object","properties":{"annotations":{"description":"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations","type":"object","additionalProperties":{"type":"string","default":""}},"creationTimestamp":{"description":"CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.\n\nPopulated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"}]},"deletionGracePeriodSeconds":{"description":"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.","type":"integer","format":"int64"},"deletionTimestamp":{"description":"DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.\n\nPopulated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"}]},"finalizers":{"description":"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.","type":"array","items":{"type":"string","default":""},"x-kubernetes-patch-strategy":"merge"},"generateName":{"description":"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\n\nIf this field is specified and the generated name exists, the server will return a 409.\n\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency","type":"string"},"generation":{"description":"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.","type":"integer","format":"int64"},"labels":{"description":"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels","type":"object","additionalProperties":{"type":"string","default":""}},"managedFields":{"description":"ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry"}]}},"name":{"description":"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names","type":"string"},"namespace":{"description":"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\n\nMust be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces","type":"string"},"ownerReferences":{"description":"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference"}]},"x-kubernetes-patch-merge-key":"uid","x-kubernetes-patch-strategy":"merge"},"resourceVersion":{"description":"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\n\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency","type":"string"},"selfLink":{"description":"Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.","type":"string"},"uid":{"description":"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\n\nPopulated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids","type":"string"}}},"io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference":{"description":"OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.","type":"object","required":["apiVersion","kind","name","uid"],"properties":{"apiVersion":{"description":"API version of the referent.","type":"string","default":""},"blockOwnerDeletion":{"description":"If true, AND if the owner has the \"foregroundDeletion\" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs \"delete\" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.","type":"boolean"},"controller":{"description":"If true, this reference points to the managing controller.","type":"boolean"},"kind":{"description":"Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string","default":""},"name":{"description":"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names","type":"string","default":""},"uid":{"description":"UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids","type":"string","default":""}},"x-kubernetes-map-type":"atomic"},"io.k8s.apimachinery.pkg.apis.meta.v1.Patch":{"description":"Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.","type":"object"},"io.k8s.apimachinery.pkg.apis.meta.v1.Preconditions":{"description":"Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.","type":"object","properties":{"resourceVersion":{"description":"Specifies the target ResourceVersion","type":"string"},"uid":{"description":"Specifies the target UID.","type":"string"}}},"io.k8s.apimachinery.pkg.apis.meta.v1.Status":{"description":"Status is a return value for calls that don't return other objects.","type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"code":{"description":"Suggested HTTP return code for this status, 0 if not set.","type":"integer","format":"int32"},"details":{"description":"Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails"}]},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"message":{"description":"A human-readable description of the status of this operation.","type":"string"},"metadata":{"description":"Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"}]},"reason":{"description":"A machine-readable description of why this operation is in the \"Failure\" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.","type":"string"},"status":{"description":"Status of the operation. One of: \"Success\" or \"Failure\". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status","type":"string"}}},"io.k8s.apimachinery.pkg.apis.meta.v1.StatusCause":{"description":"StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.","type":"object","properties":{"field":{"description":"The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.\n\nExamples:\n  \"name\" - the field \"name\" on the current resource\n  \"items[0].name\" - the field \"name\" on the first array entry in \"items\"","type":"string"},"message":{"description":"A human-readable description of the cause of the error.  This field may be presented as-is to a reader.","type":"string"},"reason":{"description":"A machine-readable description of the cause of the error. If this value is empty there is no information available.","type":"string"}}},"io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails":{"description":"StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.","type":"object","properties":{"causes":{"description":"The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.","type":"array","items":{"default":{},"allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.StatusCause"}]}},"group":{"description":"The group attribute of the resource associated with the status StatusReason.","type":"string"},"kind":{"description":"The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"name":{"description":"The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).","type":"string"},"retryAfterSeconds":{"description":"If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.","type":"integer","format":"int32"},"uid":{"description":"UID of the resource. (when there is a single resource which can be described). More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids","type":"string"}}},"io.k8s.apimachinery.pkg.apis.meta.v1.Time":{"description":"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.","type":"string","format":"date-time"},"io.strimzi.kafka.v1beta2.Kafka":{"type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"}]},"spec":{"description":"The specification of the Kafka and ZooKeeper clusters, and Topic Operator.","type":"object","required":["kafka","zookeeper"],"properties":{"clientsCa":{"description":"Configuration of the clients certificate authority.","type":"object","properties":{"certificateExpirationPolicy":{"description":"How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.","type":"string","enum":["renew-certificate","replace-key"]},"generateCertificateAuthority":{"description":"If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.","type":"boolean"},"generateSecretOwnerReference":{"description":"If `true`, the Cluster and Client CA Secrets are configured with the `ownerReference` set to the `Kafka` resource. If the `Kafka` resource is deleted when `true`, the CA Secrets are also deleted. If `false`, the `ownerReference` is disabled. If the `Kafka` resource is deleted when `false`, the CA Secrets are retained and available for reuse. Default is `true`.","type":"boolean"},"renewalDays":{"description":"The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.","type":"integer","minimum":1},"validityDays":{"description":"The number of days generated certificates should be valid for. The default is 365.","type":"integer","minimum":1}}},"clusterCa":{"description":"Configuration of the cluster certificate authority.","type":"object","properties":{"certificateExpirationPolicy":{"description":"How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.","type":"string","enum":["renew-certificate","replace-key"]},"generateCertificateAuthority":{"description":"If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.","type":"boolean"},"generateSecretOwnerReference":{"description":"If `true`, the Cluster and Client CA Secrets are configured with the `ownerReference` set to the `Kafka` resource. If the `Kafka` resource is deleted when `true`, the CA Secrets are also deleted. If `false`, the `ownerReference` is disabled. If the `Kafka` resource is deleted when `false`, the CA Secrets are retained and available for reuse. Default is `true`.","type":"boolean"},"renewalDays":{"description":"The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.","type":"integer","minimum":1},"validityDays":{"description":"The number of days generated certificates should be valid for. The default is 365.","type":"integer","minimum":1}}},"cruiseControl":{"description":"Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.","type":"object","properties":{"brokerCapacity":{"description":"The Cruise Control `brokerCapacity` configuration.","type":"object","properties":{"cpu":{"description":"Broker capacity for CPU resource in cores or millicores. For example, 1, 1.500, 1500m. For more information on valid CPU resource units see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu.","type":"string","pattern":"^[0-9]+([.][0-9]{0,3}|[m]?)$"},"cpuUtilization":{"description":"Broker capacity for CPU resource utilization as a percentage (0 - 100).","type":"integer","maximum":100,"minimum":0},"disk":{"description":"Broker capacity for disk in bytes. Use a number value with either standard Kubernetes byte units (K, M, G, or T), their bibyte (power of two) equivalents (Ki, Mi, Gi, or Ti), or a byte value with or without E notation. For example, 100000M, 100000Mi, 104857600000, or 1e+11.","type":"string","pattern":"^[0-9]+([.][0-9]*)?([KMGTPE]i?|e[0-9]+)?$"},"inboundNetwork":{"description":"Broker capacity for inbound network throughput in bytes per second. Use an integer value with standard Kubernetes byte units (K, M, G) or their bibyte (power of two) equivalents (Ki, Mi, Gi) per second. For example, 10000KiB/s.","type":"string","pattern":"^[0-9]+([KMG]i?)?B/s$"},"outboundNetwork":{"description":"Broker capacity for outbound network throughput in bytes per second. Use an integer value with standard Kubernetes byte units (K, M, G) or their bibyte (power of two) equivalents (Ki, Mi, Gi) per second. For example, 10000KiB/s.","type":"string","pattern":"^[0-9]+([KMG]i?)?B/s$"},"overrides":{"description":"Overrides for individual brokers. The `overrides` property lets you specify a different capacity configuration for different brokers.","type":"array","items":{"type":"object","required":["brokers"],"properties":{"brokers":{"description":"List of Kafka brokers (broker identifiers).","type":"array","items":{"type":"integer"}},"cpu":{"description":"Broker capacity for CPU resource in cores or millicores. For example, 1, 1.500, 1500m. For more information on valid CPU resource units see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu.","type":"string","pattern":"^[0-9]+([.][0-9]{0,3}|[m]?)$"},"inboundNetwork":{"description":"Broker capacity for inbound network throughput in bytes per second. Use an integer value with standard Kubernetes byte units (K, M, G) or their bibyte (power of two) equivalents (Ki, Mi, Gi) per second. For example, 10000KiB/s.","type":"string","pattern":"^[0-9]+([KMG]i?)?B/s$"},"outboundNetwork":{"description":"Broker capacity for outbound network throughput in bytes per second. Use an integer value with standard Kubernetes byte units (K, M, G) or their bibyte (power of two) equivalents (Ki, Mi, Gi) per second. For example, 10000KiB/s.","type":"string","pattern":"^[0-9]+([KMG]i?)?B/s$"}}}}}},"config":{"description":"The Cruise Control configuration. For a full list of configuration options refer to https://github.com/linkedin/cruise-control/wiki/Configurations. Note that properties with the following prefixes cannot be set: bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,metric.reporter.sampler.bootstrap.servers, capacity.config.file, self.healing., ssl., kafka.broker.failure.detection.enable, topic.config.provider.class (with the exception of: ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols, webserver.http.cors.enabled, webserver.http.cors.origin, webserver.http.cors.exposeheaders, webserver.security.enable, webserver.ssl.enable).","type":"object","x-kubernetes-preserve-unknown-fields":true},"image":{"description":"The docker image for the pods.","type":"string"},"jvmOptions":{"description":"JVM Options for the Cruise Control container.","type":"object","properties":{"-XX":{"description":"A map of -XX options to the JVM.","type":"object","x-kubernetes-preserve-unknown-fields":true},"-Xms":{"description":"-Xms option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"-Xmx":{"description":"-Xmx option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"gcLoggingEnabled":{"description":"Specifies whether the Garbage Collection logging is enabled. The default is false.","type":"boolean"},"javaSystemProperties":{"description":"A map of additional system properties which will be passed using the `-D` option to the JVM.","type":"array","items":{"type":"object","properties":{"name":{"description":"The system property name.","type":"string"},"value":{"description":"The system property value.","type":"string"}}}}}},"livenessProbe":{"description":"Pod liveness checking for the Cruise Control container.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"logging":{"description":"Logging configuration (Log4j 2) for Cruise Control.","type":"object","required":["type"],"properties":{"loggers":{"description":"A Map from logger name to logger level.","type":"object","x-kubernetes-preserve-unknown-fields":true},"type":{"description":"Logging type, must be either 'inline' or 'external'.","type":"string","enum":["inline","external"]},"valueFrom":{"description":"`ConfigMap` entry where the logging configuration is stored. ","type":"object","properties":{"configMapKeyRef":{"description":"Reference to the key in the ConfigMap containing the configuration.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}},"metricsConfig":{"description":"Metrics configuration.","type":"object","required":["type","valueFrom"],"properties":{"type":{"description":"Metrics type. Only 'jmxPrometheusExporter' supported currently.","type":"string","enum":["jmxPrometheusExporter"]},"valueFrom":{"description":"ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.","type":"object","properties":{"configMapKeyRef":{"description":"Reference to the key in the ConfigMap containing the configuration.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}},"readinessProbe":{"description":"Pod readiness checking for the Cruise Control container.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"resources":{"description":"CPU and memory resources to reserve for the Cruise Control container.","type":"object","properties":{"claims":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"limits":{"type":"object","x-kubernetes-preserve-unknown-fields":true},"requests":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"template":{"description":"Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.","type":"object","properties":{"apiService":{"description":"Template for Cruise Control API `Service`.","type":"object","properties":{"ipFamilies":{"description":"Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.","type":"array","items":{"type":"string","enum":["IPv4","IPv6"]}},"ipFamilyPolicy":{"description":"Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.","type":"string","enum":["SingleStack","PreferDualStack","RequireDualStack"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"cruiseControlContainer":{"description":"Template for the Cruise Control container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"deployment":{"description":"Template for Cruise Control `Deployment`.","type":"object","properties":{"deploymentStrategy":{"description":"Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.","type":"string","enum":["RollingUpdate","Recreate"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"pod":{"description":"Template for Cruise Control `Pods`.","type":"object","properties":{"affinity":{"description":"The pod's affinity rules.","type":"object","properties":{"nodeAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"preference":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"object","properties":{"nodeSelectorTerms":{"type":"array","items":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}}}}}}},"podAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}},"podAntiAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}}}},"enableServiceLinks":{"description":"Indicates whether information about services should be injected into Pod's environment variables.","type":"boolean"},"hostAliases":{"description":"The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.","type":"array","items":{"type":"object","properties":{"hostnames":{"type":"array","items":{"type":"string"}},"ip":{"type":"string"}}}},"imagePullSecrets":{"description":"List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.","type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"priorityClassName":{"description":"The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.","type":"string"},"schedulerName":{"description":"The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.","type":"string"},"securityContext":{"description":"Configures pod-level security attributes and common container settings.","type":"object","properties":{"fsGroup":{"type":"integer"},"fsGroupChangePolicy":{"type":"string"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"supplementalGroups":{"type":"array","items":{"type":"integer"}},"sysctls":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"value":{"type":"string"}}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}},"terminationGracePeriodSeconds":{"description":"The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.","type":"integer","minimum":0},"tmpDirSizeLimit":{"description":"Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"tolerations":{"description":"The pod's tolerations.","type":"array","items":{"type":"object","properties":{"effect":{"type":"string"},"key":{"type":"string"},"operator":{"type":"string"},"tolerationSeconds":{"type":"integer"},"value":{"type":"string"}}}},"topologySpreadConstraints":{"description":"The pod's topology spread constraints.","type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"matchLabelKeys":{"type":"array","items":{"type":"string"}},"maxSkew":{"type":"integer"},"minDomains":{"type":"integer"},"nodeAffinityPolicy":{"type":"string"},"nodeTaintsPolicy":{"type":"string"},"topologyKey":{"type":"string"},"whenUnsatisfiable":{"type":"string"}}}}}},"podDisruptionBudget":{"description":"Template for Cruise Control `PodDisruptionBudget`.","type":"object","properties":{"maxUnavailable":{"description":"Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.","type":"integer","minimum":0},"metadata":{"description":"Metadata to apply to the `PodDisruptionBudgetTemplate` resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"serviceAccount":{"description":"Template for the Cruise Control service account.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"tlsSidecarContainer":{"description":"Template for the Cruise Control TLS sidecar container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}}}},"tlsSidecar":{"description":"TLS sidecar configuration.","type":"object","properties":{"image":{"description":"The docker image for the container.","type":"string"},"livenessProbe":{"description":"Pod liveness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"logLevel":{"description":"The log level for the TLS sidecar. Default value is `notice`.","type":"string","enum":["emerg","alert","crit","err","warning","notice","info","debug"]},"readinessProbe":{"description":"Pod readiness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"resources":{"description":"CPU and memory resources to reserve.","type":"object","properties":{"claims":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"limits":{"type":"object","x-kubernetes-preserve-unknown-fields":true},"requests":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}}}}}},"entityOperator":{"description":"Configuration of the Entity Operator.","type":"object","properties":{"template":{"description":"Template for Entity Operator resources. The template allows users to specify how a `Deployment` and `Pod` is generated.","type":"object","properties":{"deployment":{"description":"Template for Entity Operator `Deployment`.","type":"object","properties":{"deploymentStrategy":{"description":"Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.","type":"string","enum":["RollingUpdate","Recreate"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"entityOperatorRole":{"description":"Template for the Entity Operator Role.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"pod":{"description":"Template for Entity Operator `Pods`.","type":"object","properties":{"affinity":{"description":"The pod's affinity rules.","type":"object","properties":{"nodeAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"preference":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"object","properties":{"nodeSelectorTerms":{"type":"array","items":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}}}}}}},"podAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}},"podAntiAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}}}},"enableServiceLinks":{"description":"Indicates whether information about services should be injected into Pod's environment variables.","type":"boolean"},"hostAliases":{"description":"The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.","type":"array","items":{"type":"object","properties":{"hostnames":{"type":"array","items":{"type":"string"}},"ip":{"type":"string"}}}},"imagePullSecrets":{"description":"List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.","type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"priorityClassName":{"description":"The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.","type":"string"},"schedulerName":{"description":"The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.","type":"string"},"securityContext":{"description":"Configures pod-level security attributes and common container settings.","type":"object","properties":{"fsGroup":{"type":"integer"},"fsGroupChangePolicy":{"type":"string"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"supplementalGroups":{"type":"array","items":{"type":"integer"}},"sysctls":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"value":{"type":"string"}}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}},"terminationGracePeriodSeconds":{"description":"The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.","type":"integer","minimum":0},"tmpDirSizeLimit":{"description":"Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"tolerations":{"description":"The pod's tolerations.","type":"array","items":{"type":"object","properties":{"effect":{"type":"string"},"key":{"type":"string"},"operator":{"type":"string"},"tolerationSeconds":{"type":"integer"},"value":{"type":"string"}}}},"topologySpreadConstraints":{"description":"The pod's topology spread constraints.","type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"matchLabelKeys":{"type":"array","items":{"type":"string"}},"maxSkew":{"type":"integer"},"minDomains":{"type":"integer"},"nodeAffinityPolicy":{"type":"string"},"nodeTaintsPolicy":{"type":"string"},"topologyKey":{"type":"string"},"whenUnsatisfiable":{"type":"string"}}}}}},"serviceAccount":{"description":"Template for the Entity Operator service account.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"tlsSidecarContainer":{"description":"Template for the Entity Operator TLS sidecar container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"topicOperatorContainer":{"description":"Template for the Entity Topic Operator container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"topicOperatorRoleBinding":{"description":"Template for the Entity Topic Operator RoleBinding.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"userOperatorContainer":{"description":"Template for the Entity User Operator container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"userOperatorRoleBinding":{"description":"Template for the Entity Topic Operator RoleBinding.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}}}},"tlsSidecar":{"description":"TLS sidecar configuration.","type":"object","properties":{"image":{"description":"The docker image for the container.","type":"string"},"livenessProbe":{"description":"Pod liveness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"logLevel":{"description":"The log level for the TLS sidecar. Default value is `notice`.","type":"string","enum":["emerg","alert","crit","err","warning","notice","info","debug"]},"readinessProbe":{"description":"Pod readiness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"resources":{"description":"CPU and memory resources to reserve.","type":"object","properties":{"claims":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"limits":{"type":"object","x-kubernetes-preserve-unknown-fields":true},"requests":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"topicOperator":{"description":"Configuration of the Topic Operator.","type":"object","properties":{"image":{"description":"The image to use for the Topic Operator.","type":"string"},"jvmOptions":{"description":"JVM Options for pods.","type":"object","properties":{"-XX":{"description":"A map of -XX options to the JVM.","type":"object","x-kubernetes-preserve-unknown-fields":true},"-Xms":{"description":"-Xms option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"-Xmx":{"description":"-Xmx option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"gcLoggingEnabled":{"description":"Specifies whether the Garbage Collection logging is enabled. The default is false.","type":"boolean"},"javaSystemProperties":{"description":"A map of additional system properties which will be passed using the `-D` option to the JVM.","type":"array","items":{"type":"object","properties":{"name":{"description":"The system property name.","type":"string"},"value":{"description":"The system property value.","type":"string"}}}}}},"livenessProbe":{"description":"Pod liveness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"logging":{"description":"Logging configuration.","type":"object","required":["type"],"properties":{"loggers":{"description":"A Map from logger name to logger level.","type":"object","x-kubernetes-preserve-unknown-fields":true},"type":{"description":"Logging type, must be either 'inline' or 'external'.","type":"string","enum":["inline","external"]},"valueFrom":{"description":"`ConfigMap` entry where the logging configuration is stored. ","type":"object","properties":{"configMapKeyRef":{"description":"Reference to the key in the ConfigMap containing the configuration.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}},"readinessProbe":{"description":"Pod readiness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"reconciliationIntervalSeconds":{"description":"Interval between periodic reconciliations.","type":"integer","minimum":0},"resources":{"description":"CPU and memory resources to reserve.","type":"object","properties":{"claims":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"limits":{"type":"object","x-kubernetes-preserve-unknown-fields":true},"requests":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"startupProbe":{"description":"Pod startup checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"topicMetadataMaxAttempts":{"description":"The number of attempts at getting topic metadata.","type":"integer","minimum":0},"watchedNamespace":{"description":"The namespace the Topic Operator should watch.","type":"string"},"zookeeperSessionTimeoutSeconds":{"description":"Timeout for the ZooKeeper session.","type":"integer","minimum":0}}},"userOperator":{"description":"Configuration of the User Operator.","type":"object","properties":{"image":{"description":"The image to use for the User Operator.","type":"string"},"jvmOptions":{"description":"JVM Options for pods.","type":"object","properties":{"-XX":{"description":"A map of -XX options to the JVM.","type":"object","x-kubernetes-preserve-unknown-fields":true},"-Xms":{"description":"-Xms option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"-Xmx":{"description":"-Xmx option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"gcLoggingEnabled":{"description":"Specifies whether the Garbage Collection logging is enabled. The default is false.","type":"boolean"},"javaSystemProperties":{"description":"A map of additional system properties which will be passed using the `-D` option to the JVM.","type":"array","items":{"type":"object","properties":{"name":{"description":"The system property name.","type":"string"},"value":{"description":"The system property value.","type":"string"}}}}}},"livenessProbe":{"description":"Pod liveness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"logging":{"description":"Logging configuration.","type":"object","required":["type"],"properties":{"loggers":{"description":"A Map from logger name to logger level.","type":"object","x-kubernetes-preserve-unknown-fields":true},"type":{"description":"Logging type, must be either 'inline' or 'external'.","type":"string","enum":["inline","external"]},"valueFrom":{"description":"`ConfigMap` entry where the logging configuration is stored. ","type":"object","properties":{"configMapKeyRef":{"description":"Reference to the key in the ConfigMap containing the configuration.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}},"readinessProbe":{"description":"Pod readiness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"reconciliationIntervalSeconds":{"description":"Interval between periodic reconciliations.","type":"integer","minimum":0},"resources":{"description":"CPU and memory resources to reserve.","type":"object","properties":{"claims":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"limits":{"type":"object","x-kubernetes-preserve-unknown-fields":true},"requests":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"secretPrefix":{"description":"The prefix that will be added to the KafkaUser name to be used as the Secret name.","type":"string"},"watchedNamespace":{"description":"The namespace the User Operator should watch.","type":"string"},"zookeeperSessionTimeoutSeconds":{"description":"Timeout for the ZooKeeper session.","type":"integer","minimum":0}}}}},"jmxTrans":{"description":"As of Strimzi 0.35.0, JMXTrans is not supported anymore and this option is ignored.","type":"object","required":["outputDefinitions","kafkaQueries"],"properties":{"image":{"description":"The image to use for the JmxTrans.","type":"string"},"kafkaQueries":{"description":"Queries to send to the Kafka brokers to define what data should be read from each broker. For more information on these properties see, xref:type-JmxTransQueryTemplate-reference[`JmxTransQueryTemplate` schema reference].","type":"array","items":{"type":"object","required":["targetMBean","attributes","outputs"],"properties":{"attributes":{"description":"Determine which attributes of the targeted MBean should be included.","type":"array","items":{"type":"string"}},"outputs":{"description":"List of the names of output definitions specified in the spec.kafka.jmxTrans.outputDefinitions that have defined where JMX metrics are pushed to, and in which data format.","type":"array","items":{"type":"string"}},"targetMBean":{"description":"If using wildcards instead of a specific MBean then the data is gathered from multiple MBeans. Otherwise if specifying an MBean then data is gathered from that specified MBean.","type":"string"}}}},"logLevel":{"description":"Sets the logging level of the JmxTrans deployment.For more information see, https://github.com/jmxtrans/jmxtrans-agent/wiki/Troubleshooting[JmxTrans Logging Level].","type":"string"},"outputDefinitions":{"description":"Defines the output hosts that will be referenced later on. For more information on these properties see, xref:type-JmxTransOutputDefinitionTemplate-reference[`JmxTransOutputDefinitionTemplate` schema reference].","type":"array","items":{"type":"object","required":["outputType","name"],"properties":{"flushDelayInSeconds":{"description":"How many seconds the JmxTrans waits before pushing a new set of data out.","type":"integer"},"host":{"description":"The DNS/hostname of the remote host that the data is pushed to.","type":"string"},"name":{"description":"Template for setting the name of the output definition. This is used to identify where to send the results of queries should be sent.","type":"string"},"outputType":{"description":"Template for setting the format of the data that will be pushed.For more information see https://github.com/jmxtrans/jmxtrans/wiki/OutputWriters[JmxTrans OutputWriters].","type":"string"},"port":{"description":"The port of the remote host that the data is pushed to.","type":"integer"},"typeNames":{"description":"Template for filtering data to be included in response to a wildcard query. For more information see https://github.com/jmxtrans/jmxtrans/wiki/Queries[JmxTrans queries].","type":"array","items":{"type":"string"}}}}},"resources":{"description":"CPU and memory resources to reserve.","type":"object","properties":{"claims":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"limits":{"type":"object","x-kubernetes-preserve-unknown-fields":true},"requests":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"template":{"description":"Template for JmxTrans resources.","type":"object","properties":{"container":{"description":"Template for JmxTrans container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"deployment":{"description":"Template for JmxTrans `Deployment`.","type":"object","properties":{"deploymentStrategy":{"description":"Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.","type":"string","enum":["RollingUpdate","Recreate"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"pod":{"description":"Template for JmxTrans `Pods`.","type":"object","properties":{"affinity":{"description":"The pod's affinity rules.","type":"object","properties":{"nodeAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"preference":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"object","properties":{"nodeSelectorTerms":{"type":"array","items":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}}}}}}},"podAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}},"podAntiAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}}}},"enableServiceLinks":{"description":"Indicates whether information about services should be injected into Pod's environment variables.","type":"boolean"},"hostAliases":{"description":"The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.","type":"array","items":{"type":"object","properties":{"hostnames":{"type":"array","items":{"type":"string"}},"ip":{"type":"string"}}}},"imagePullSecrets":{"description":"List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.","type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"priorityClassName":{"description":"The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.","type":"string"},"schedulerName":{"description":"The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.","type":"string"},"securityContext":{"description":"Configures pod-level security attributes and common container settings.","type":"object","properties":{"fsGroup":{"type":"integer"},"fsGroupChangePolicy":{"type":"string"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"supplementalGroups":{"type":"array","items":{"type":"integer"}},"sysctls":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"value":{"type":"string"}}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}},"terminationGracePeriodSeconds":{"description":"The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.","type":"integer","minimum":0},"tmpDirSizeLimit":{"description":"Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"tolerations":{"description":"The pod's tolerations.","type":"array","items":{"type":"object","properties":{"effect":{"type":"string"},"key":{"type":"string"},"operator":{"type":"string"},"tolerationSeconds":{"type":"integer"},"value":{"type":"string"}}}},"topologySpreadConstraints":{"description":"The pod's topology spread constraints.","type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"matchLabelKeys":{"type":"array","items":{"type":"string"}},"maxSkew":{"type":"integer"},"minDomains":{"type":"integer"},"nodeAffinityPolicy":{"type":"string"},"nodeTaintsPolicy":{"type":"string"},"topologyKey":{"type":"string"},"whenUnsatisfiable":{"type":"string"}}}}}},"serviceAccount":{"description":"Template for the JmxTrans service account.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}}}}}},"kafka":{"description":"Configuration of the Kafka cluster.","type":"object","required":["replicas","listeners","storage"],"properties":{"authorization":{"description":"Authorization configuration for Kafka brokers.","type":"object","required":["type"],"properties":{"allowOnError":{"description":"Defines whether a Kafka client should be allowed or denied by default when the authorizer fails to query the Open Policy Agent, for example, when it is temporarily unavailable). Defaults to `false` - all actions will be denied.","type":"boolean"},"authorizerClass":{"description":"Authorization implementation class, which must be available in classpath.","type":"string"},"clientId":{"description":"OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.","type":"string"},"connectTimeoutSeconds":{"description":"The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.","type":"integer","minimum":1},"delegateToKafkaAcls":{"description":"Whether authorization decision should be delegated to the 'Simple' authorizer if DENIED by Keycloak Authorization Services policies. Default value is `false`.","type":"boolean"},"disableTlsHostnameVerification":{"description":"Enable or disable TLS hostname verification. Default value is `false`.","type":"boolean"},"enableMetrics":{"description":"Enable or disable OAuth metrics. The default value is `false`.","type":"boolean"},"expireAfterMs":{"description":"The expiration of the records kept in the local cache to avoid querying the Open Policy Agent for every request. Defines how often the cached authorization decisions are reloaded from the Open Policy Agent server. In milliseconds. Defaults to `3600000`.","type":"integer"},"grantsAlwaysLatest":{"description":"Controls whether the latest grants are fetched for a new session. When enabled, grants are retrieved from Keycloak and cached for the user. The default value is `false`.","type":"boolean"},"grantsGcPeriodSeconds":{"description":"The time, in seconds, between consecutive runs of a job that cleans stale grants from the cache. The default value is 300.","type":"integer","minimum":1},"grantsMaxIdleTimeSeconds":{"description":"The time, in seconds, after which an idle grant can be evicted from the cache. The default value is 300.","type":"integer","minimum":1},"grantsRefreshPeriodSeconds":{"description":"The time between two consecutive grants refresh runs in seconds. The default value is 60.","type":"integer","minimum":0},"grantsRefreshPoolSize":{"description":"The number of threads to use to refresh grants for active sessions. The more threads, the more parallelism, so the sooner the job completes. However, using more threads places a heavier load on the authorization server. The default value is 5.","type":"integer","minimum":1},"httpRetries":{"description":"The maximum number of retries to attempt if an initial HTTP request fails. If not set, the default is to not attempt any retries.","type":"integer","minimum":0},"initialCacheCapacity":{"description":"Initial capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request Defaults to `5000`.","type":"integer"},"maximumCacheSize":{"description":"Maximum capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request. Defaults to `50000`.","type":"integer"},"readTimeoutSeconds":{"description":"The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.","type":"integer","minimum":1},"superUsers":{"description":"List of super users, which are user principals with unlimited access rights.","type":"array","items":{"type":"string"}},"supportsAdminApi":{"description":"Indicates whether the custom authorizer supports the APIs for managing ACLs using the Kafka Admin API. Defaults to `false`.","type":"boolean"},"tlsTrustedCertificates":{"description":"Trusted certificates for TLS connection to the OAuth server.","type":"array","items":{"type":"object","required":["certificate","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}}},"tokenEndpointUri":{"description":"Authorization server token endpoint URI.","type":"string"},"type":{"description":"Authorization type. Currently, the supported types are `simple`, `keycloak`, `opa` and `custom`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization. `keycloak` authorization type uses Keycloak Authorization Services for authorization. `opa` authorization type uses Open Policy Agent based authorization.`custom` authorization type uses user-provided implementation for authorization.","type":"string","enum":["simple","opa","keycloak","custom"]},"url":{"description":"The URL used to connect to the Open Policy Agent server. The URL has to include the policy which will be queried by the authorizer. This option is required.","type":"string"}}},"brokerRackInitImage":{"description":"The image of the init container used for initializing the `broker.rack`.","type":"string"},"config":{"description":"Kafka broker config properties with the following prefixes cannot be set: listeners, advertised., broker., listener., host.name, port, inter.broker.listener.name, sasl., ssl., security., password., log.dir, zookeeper.connect, zookeeper.set.acl, zookeeper.ssl, zookeeper.clientCnxnSocket, authorizer., super.user, cruise.control.metrics.topic, cruise.control.metrics.reporter.bootstrap.servers,node.id, process.roles, controller. (with the exception of: zookeeper.connection.timeout.ms, sasl.server.max.receive.size,ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols, ssl.secure.random.implementation,cruise.control.metrics.topic.num.partitions, cruise.control.metrics.topic.replication.factor, cruise.control.metrics.topic.retention.ms,cruise.control.metrics.topic.auto.create.retries, cruise.control.metrics.topic.auto.create.timeout.ms,cruise.control.metrics.topic.min.insync.replicas,controller.quorum.election.backoff.max.ms, controller.quorum.election.timeout.ms, controller.quorum.fetch.timeout.ms).","type":"object","x-kubernetes-preserve-unknown-fields":true},"image":{"description":"The docker image for the pods. The default value depends on the configured `Kafka.spec.kafka.version`.","type":"string"},"jmxOptions":{"description":"JMX Options for Kafka brokers.","type":"object","properties":{"authentication":{"description":"Authentication configuration for connecting to the JMX port.","type":"object","required":["type"],"properties":{"type":{"description":"Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.","type":"string","enum":["password"]}}}}},"jvmOptions":{"description":"JVM Options for pods.","type":"object","properties":{"-XX":{"description":"A map of -XX options to the JVM.","type":"object","x-kubernetes-preserve-unknown-fields":true},"-Xms":{"description":"-Xms option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"-Xmx":{"description":"-Xmx option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"gcLoggingEnabled":{"description":"Specifies whether the Garbage Collection logging is enabled. The default is false.","type":"boolean"},"javaSystemProperties":{"description":"A map of additional system properties which will be passed using the `-D` option to the JVM.","type":"array","items":{"type":"object","properties":{"name":{"description":"The system property name.","type":"string"},"value":{"description":"The system property value.","type":"string"}}}}}},"listeners":{"description":"Configures listeners of Kafka brokers.","type":"array","minItems":1,"items":{"type":"object","required":["name","port","type","tls"],"properties":{"authentication":{"description":"Authentication configuration for this listener.","type":"object","required":["type"],"properties":{"accessTokenIsJwt":{"description":"Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.","type":"boolean"},"checkAccessTokenType":{"description":"Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.","type":"boolean"},"checkAudience":{"description":"Enable or disable audience checking. Audience checks identify the recipients of tokens. If audience checking is enabled, the OAuth Client ID also has to be configured using the `clientId` property. The Kafka broker will reject tokens that do not have its `clientId` in their `aud` (audience) claim.Default value is `false`.","type":"boolean"},"checkIssuer":{"description":"Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.","type":"boolean"},"clientAudience":{"description":"The audience to use when making requests to the authorization server's token endpoint. Used for inter-broker authentication and for configuring OAuth 2.0 over PLAIN using the `clientId` and `secret` method.","type":"string"},"clientId":{"description":"OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.","type":"string"},"clientScope":{"description":"The scope to use when making requests to the authorization server's token endpoint. Used for inter-broker authentication and for configuring OAuth 2.0 over PLAIN using the `clientId` and `secret` method.","type":"string"},"clientSecret":{"description":"Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.","type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}},"connectTimeoutSeconds":{"description":"The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.","type":"integer"},"customClaimCheck":{"description":"JsonPath filter query to be applied to the JWT token or to the response of the introspection endpoint for additional token validation. Not set by default.","type":"string"},"disableTlsHostnameVerification":{"description":"Enable or disable TLS hostname verification. Default value is `false`.","type":"boolean"},"enableECDSA":{"description":"Enable or disable ECDSA support by installing BouncyCastle crypto provider. ECDSA support is always enabled. The BouncyCastle libraries are no longer packaged with Strimzi. Value is ignored.","type":"boolean"},"enableMetrics":{"description":"Enable or disable OAuth metrics. Default value is `false`.","type":"boolean"},"enableOauthBearer":{"description":"Enable or disable OAuth authentication over SASL_OAUTHBEARER. Default value is `true`.","type":"boolean"},"enablePlain":{"description":"Enable or disable OAuth authentication over SASL_PLAIN. There is no re-authentication support when this mechanism is used. Default value is `false`.","type":"boolean"},"failFast":{"description":"Enable or disable termination of Kafka broker processes due to potentially recoverable runtime errors during startup. Default value is `true`.","type":"boolean"},"fallbackUserNameClaim":{"description":"The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.","type":"string"},"fallbackUserNamePrefix":{"description":"The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.","type":"string"},"groupsClaim":{"description":"JsonPath query used to extract groups for the user during authentication. Extracted groups can be used by a custom authorizer. By default no groups are extracted.","type":"string"},"groupsClaimDelimiter":{"description":"A delimiter used to parse groups when they are extracted as a single String value rather than a JSON array. Default value is ',' (comma).","type":"string"},"httpRetries":{"description":"The maximum number of retries to attempt if an initial HTTP request fails. If not set, the default is to not attempt any retries.","type":"integer"},"httpRetryPauseMs":{"description":"The pause to take before retrying a failed HTTP request. If not set, the default is to not pause at all but to immediately repeat a request.","type":"integer"},"introspectionEndpointUri":{"description":"URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.","type":"string"},"jwksEndpointUri":{"description":"URI of the JWKS certificate endpoint, which can be used for local JWT validation.","type":"string"},"jwksExpirySeconds":{"description":"Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.","type":"integer","minimum":1},"jwksIgnoreKeyUse":{"description":"Flag to ignore the 'use' attribute of `key` declarations in a JWKS endpoint response. Default value is `false`.","type":"boolean"},"jwksMinRefreshPauseSeconds":{"description":"The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.","type":"integer","minimum":0},"jwksRefreshSeconds":{"description":"Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.","type":"integer","minimum":1},"listenerConfig":{"description":"Configuration to be used for a specific listener. All values are prefixed with listener.name._\u003clistener_name\u003e_.","type":"object","x-kubernetes-preserve-unknown-fields":true},"maxSecondsWithoutReauthentication":{"description":"Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires. This option only applies to SASL_OAUTHBEARER authentication mechanism (when `enableOauthBearer` is `true`).","type":"integer"},"readTimeoutSeconds":{"description":"The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.","type":"integer"},"sasl":{"description":"Enable or disable SASL on this listener.","type":"boolean"},"secrets":{"description":"Secrets to be mounted to /opt/kafka/custom-authn-secrets/custom-listener-_\u003clistener_name\u003e-\u003cport\u003e_/_\u003csecret_name\u003e_.","type":"array","items":{"type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}}},"tlsTrustedCertificates":{"description":"Trusted certificates for TLS connection to the OAuth server.","type":"array","items":{"type":"object","required":["certificate","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}}},"tokenEndpointUri":{"description":"URI of the Token Endpoint to use with SASL_PLAIN mechanism when the client authenticates with `clientId` and a `secret`. If set, the client can authenticate over SASL_PLAIN by either setting `username` to `clientId`, and setting `password` to client `secret`, or by setting `username` to account username, and `password` to access token prefixed with `$accessToken:`. If this option is not set, the `password` is always interpreted as an access token (without a prefix), and `username` as the account username (a so called 'no-client-credentials' mode).","type":"string"},"type":{"description":"Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.`custom` type allows for any authentication type to be used.","type":"string","enum":["tls","scram-sha-512","oauth","custom"]},"userInfoEndpointUri":{"description":"URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. ","type":"string"},"userNameClaim":{"description":"Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.","type":"string"},"validIssuerUri":{"description":"URI of the token issuer used for authentication.","type":"string"},"validTokenType":{"description":"Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.","type":"string"}}},"configuration":{"description":"Additional listener configuration.","type":"object","properties":{"bootstrap":{"description":"Bootstrap configuration.","type":"object","properties":{"alternativeNames":{"description":"Additional alternative names for the bootstrap service. The alternative names will be added to the list of subject alternative names of the TLS certificates.","type":"array","items":{"type":"string"}},"annotations":{"description":"Annotations that will be added to the `Ingress`, `Route`, or `Service` resource. You can use this field to configure DNS providers such as External DNS. This field can be used only with `loadbalancer`, `nodeport`, `route`, or `ingress` type listeners.","type":"object","x-kubernetes-preserve-unknown-fields":true},"host":{"description":"The bootstrap host. This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. This field can be used only with `route` (optional) or `ingress` (required) type listeners.","type":"string"},"labels":{"description":"Labels that will be added to the `Ingress`, `Route`, or `Service` resource. This field can be used only with `loadbalancer`, `nodeport`, `route`, or `ingress` type listeners.","type":"object","x-kubernetes-preserve-unknown-fields":true},"loadBalancerIP":{"description":"The loadbalancer is requested with the IP address specified in this field. This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. This field is ignored if the cloud provider does not support the feature.This field can be used only with `loadbalancer` type listener.","type":"string"},"nodePort":{"description":"Node port for the bootstrap service. This field can be used only with `nodeport` type listener.","type":"integer"}}},"brokerCertChainAndKey":{"description":"Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. The certificate can optionally contain the whole chain. This field can be used only with listeners with enabled TLS encryption.","type":"object","required":["certificate","key","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"key":{"description":"The name of the private key in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}},"brokers":{"description":"Per-broker configurations.","type":"array","items":{"type":"object","required":["broker"],"properties":{"advertisedHost":{"description":"The host name used in the brokers' `advertised.listeners`.","type":"string"},"advertisedPort":{"description":"The port number used in the brokers' `advertised.listeners`.","type":"integer"},"annotations":{"description":"Annotations that will be added to the `Ingress` or `Service` resource. You can use this field to configure DNS providers such as External DNS. This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.","type":"object","x-kubernetes-preserve-unknown-fields":true},"broker":{"description":"ID of the kafka broker (broker identifier). Broker IDs start from 0 and correspond to the number of broker replicas.","type":"integer"},"host":{"description":"The broker host. This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. This field can be used only with `route` (optional) or `ingress` (required) type listeners.","type":"string"},"labels":{"description":"Labels that will be added to the `Ingress`, `Route`, or `Service` resource. This field can be used only with `loadbalancer`, `nodeport`, `route`, or `ingress` type listeners.","type":"object","x-kubernetes-preserve-unknown-fields":true},"loadBalancerIP":{"description":"The loadbalancer is requested with the IP address specified in this field. This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. This field is ignored if the cloud provider does not support the feature.This field can be used only with `loadbalancer` type listener.","type":"string"},"nodePort":{"description":"Node port for the per-broker service. This field can be used only with `nodeport` type listener.","type":"integer"}}}},"class":{"description":"Configures a specific class for `Ingress` and `LoadBalancer` that defines which controller will be used. This field can only be used with `ingress` and `loadbalancer` type listeners. If not specified, the default controller is used. For an `ingress` listener, set the `ingressClassName` property in the `Ingress` resources. For a `loadbalancer` listener, set the `loadBalancerClass` property  in the `Service` resources.","type":"string"},"createBootstrapService":{"description":"Whether to create the bootstrap service or not. The bootstrap service is created by default (if not specified differently). This field can be used with the `loadBalancer` type listener.","type":"boolean"},"externalTrafficPolicy":{"description":"Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.This field can be used only with `loadbalancer` or `nodeport` type listener.","type":"string","enum":["Local","Cluster"]},"finalizers":{"description":"A list of finalizers which will be configured for the `LoadBalancer` type Services created for this listener. If supported by the platform, the finalizer `service.kubernetes.io/load-balancer-cleanup` to make sure that the external load balancer is deleted together with the service.For more information, see https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#garbage-collecting-load-balancers. This field can be used only with `loadbalancer` type listeners.","type":"array","items":{"type":"string"}},"ipFamilies":{"description":"Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.","type":"array","items":{"type":"string","enum":["IPv4","IPv6"]}},"ipFamilyPolicy":{"description":"Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.","type":"string","enum":["SingleStack","PreferDualStack","RequireDualStack"]},"loadBalancerSourceRanges":{"description":"A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. This field can be used only with `loadbalancer` type listener.","type":"array","items":{"type":"string"}},"maxConnectionCreationRate":{"description":"The maximum connection creation rate we allow in this listener at any time. New connections will be throttled if the limit is reached.","type":"integer"},"maxConnections":{"description":"The maximum number of connections we allow for this listener in the broker at any time. New connections are blocked if the limit is reached.","type":"integer"},"preferredNodePortAddressType":{"description":"Defines which address type should be used as the node address. Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. By default, the addresses will be used in the following order (the first one found will be used):\n\n* `ExternalDNS`\n* `ExternalIP`\n* `InternalDNS`\n* `InternalIP`\n* `Hostname`\n\nThis field is used to select the preferred address type, which is checked first. If no address is found for this address type, the other types are checked in the default order. This field can only be used with `nodeport` type listener.","type":"string","enum":["ExternalIP","ExternalDNS","InternalIP","InternalDNS","Hostname"]},"useServiceDnsDomain":{"description":"Configures whether the Kubernetes service DNS domain should be used or not. If set to `true`, the generated addresses will contain the service DNS domain suffix (by default `.cluster.local`, can be configured using environment variable `KUBERNETES_SERVICE_DNS_DOMAIN`). Defaults to `false`.This field can be used only with `internal` and `cluster-ip` type listeners.","type":"boolean"}}},"name":{"description":"Name of the listener. The name will be used to identify the listener and the related Kubernetes objects. The name has to be unique within given a Kafka cluster. The name can consist of lowercase characters and numbers and be up to 11 characters long.","type":"string","pattern":"^[a-z0-9]{1,11}$"},"networkPolicyPeers":{"description":"List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.","type":"array","items":{"type":"object","properties":{"ipBlock":{"type":"object","properties":{"cidr":{"type":"string"},"except":{"type":"array","items":{"type":"string"}}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"podSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}}}}},"port":{"description":"Port number used by the listener inside Kafka. The port number has to be unique within a given Kafka cluster. Allowed port numbers are 9092 and higher with the exception of ports 9404 and 9999, which are already used for Prometheus and JMX. Depending on the listener type, the port number might not be the same as the port number that connects Kafka clients.","type":"integer","minimum":9092},"tls":{"description":"Enables TLS encryption on the listener. This is a required property.","type":"boolean"},"type":{"description":"Type of the listener. Currently the supported types are `internal`, `route`, `loadbalancer`, `nodeport` and `ingress`. \n\n* `internal` type exposes Kafka internally only within the Kubernetes cluster.\n* `route` type uses OpenShift Routes to expose Kafka.\n* `loadbalancer` type uses LoadBalancer type services to expose Kafka.\n* `nodeport` type uses NodePort type services to expose Kafka.\n* `ingress` type uses Kubernetes Nginx Ingress to expose Kafka with TLS passthrough.\n* `cluster-ip` type uses a per-broker `ClusterIP` service.\n","type":"string","enum":["internal","route","loadbalancer","nodeport","ingress","cluster-ip"]}}}},"livenessProbe":{"description":"Pod liveness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"logging":{"description":"Logging configuration for Kafka.","type":"object","required":["type"],"properties":{"loggers":{"description":"A Map from logger name to logger level.","type":"object","x-kubernetes-preserve-unknown-fields":true},"type":{"description":"Logging type, must be either 'inline' or 'external'.","type":"string","enum":["inline","external"]},"valueFrom":{"description":"`ConfigMap` entry where the logging configuration is stored. ","type":"object","properties":{"configMapKeyRef":{"description":"Reference to the key in the ConfigMap containing the configuration.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}},"metricsConfig":{"description":"Metrics configuration.","type":"object","required":["type","valueFrom"],"properties":{"type":{"description":"Metrics type. Only 'jmxPrometheusExporter' supported currently.","type":"string","enum":["jmxPrometheusExporter"]},"valueFrom":{"description":"ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.","type":"object","properties":{"configMapKeyRef":{"description":"Reference to the key in the ConfigMap containing the configuration.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}},"rack":{"description":"Configuration of the `broker.rack` broker config.","type":"object","required":["topologyKey"],"properties":{"topologyKey":{"description":"A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set a broker's `broker.rack` config, and the `client.rack` config for Kafka Connect or MirrorMaker 2.","type":"string"}}},"readinessProbe":{"description":"Pod readiness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"replicas":{"description":"The number of pods in the cluster.","type":"integer","minimum":1},"resources":{"description":"CPU and memory resources to reserve.","type":"object","properties":{"claims":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"limits":{"type":"object","x-kubernetes-preserve-unknown-fields":true},"requests":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"storage":{"description":"Storage configuration (disk). Cannot be updated.","type":"object","required":["type"],"properties":{"class":{"description":"The storage class to use for dynamic volume allocation.","type":"string"},"deleteClaim":{"description":"Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.","type":"boolean"},"id":{"description":"Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.","type":"integer","minimum":0},"overrides":{"description":"Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.","type":"array","items":{"type":"object","properties":{"broker":{"description":"Id of the kafka broker (broker identifier).","type":"integer"},"class":{"description":"The storage class to use for dynamic volume allocation for this broker.","type":"string"}}}},"selector":{"description":"Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.","type":"object","x-kubernetes-preserve-unknown-fields":true},"size":{"description":"When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.","type":"string"},"sizeLimit":{"description":"When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"type":{"description":"Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.","type":"string","enum":["ephemeral","persistent-claim","jbod"]},"volumes":{"description":"List of volumes as Storage objects representing the JBOD disks array.","type":"array","items":{"type":"object","required":["type"],"properties":{"class":{"description":"The storage class to use for dynamic volume allocation.","type":"string"},"deleteClaim":{"description":"Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.","type":"boolean"},"id":{"description":"Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.","type":"integer","minimum":0},"overrides":{"description":"Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.","type":"array","items":{"type":"object","properties":{"broker":{"description":"Id of the kafka broker (broker identifier).","type":"integer"},"class":{"description":"The storage class to use for dynamic volume allocation for this broker.","type":"string"}}}},"selector":{"description":"Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.","type":"object","x-kubernetes-preserve-unknown-fields":true},"size":{"description":"When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.","type":"string"},"sizeLimit":{"description":"When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"type":{"description":"Storage type, must be either 'ephemeral' or 'persistent-claim'.","type":"string","enum":["ephemeral","persistent-claim"]}}}}}},"template":{"description":"Template for Kafka cluster resources. The template allows users to specify how the Kubernetes resources are generated.","type":"object","properties":{"bootstrapService":{"description":"Template for Kafka bootstrap `Service`.","type":"object","properties":{"ipFamilies":{"description":"Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.","type":"array","items":{"type":"string","enum":["IPv4","IPv6"]}},"ipFamilyPolicy":{"description":"Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.","type":"string","enum":["SingleStack","PreferDualStack","RequireDualStack"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"brokersService":{"description":"Template for Kafka broker `Service`.","type":"object","properties":{"ipFamilies":{"description":"Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.","type":"array","items":{"type":"string","enum":["IPv4","IPv6"]}},"ipFamilyPolicy":{"description":"Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.","type":"string","enum":["SingleStack","PreferDualStack","RequireDualStack"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"clusterCaCert":{"description":"Template for Secret with Kafka Cluster certificate public key.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"clusterRoleBinding":{"description":"Template for the Kafka ClusterRoleBinding.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"externalBootstrapIngress":{"description":"Template for Kafka external bootstrap `Ingress`.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"externalBootstrapRoute":{"description":"Template for Kafka external bootstrap `Route`.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"externalBootstrapService":{"description":"Template for Kafka external bootstrap `Service`.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"initContainer":{"description":"Template for the Kafka init container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"jmxSecret":{"description":"Template for Secret of the Kafka Cluster JMX authentication.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"kafkaContainer":{"description":"Template for the Kafka broker container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"perPodIngress":{"description":"Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"perPodRoute":{"description":"Template for Kafka per-pod `Routes` used for access from outside of OpenShift.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"perPodService":{"description":"Template for Kafka per-pod `Services` used for access from outside of Kubernetes.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"persistentVolumeClaim":{"description":"Template for all Kafka `PersistentVolumeClaims`.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"pod":{"description":"Template for Kafka `Pods`.","type":"object","properties":{"affinity":{"description":"The pod's affinity rules.","type":"object","properties":{"nodeAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"preference":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"object","properties":{"nodeSelectorTerms":{"type":"array","items":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}}}}}}},"podAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}},"podAntiAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}}}},"enableServiceLinks":{"description":"Indicates whether information about services should be injected into Pod's environment variables.","type":"boolean"},"hostAliases":{"description":"The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.","type":"array","items":{"type":"object","properties":{"hostnames":{"type":"array","items":{"type":"string"}},"ip":{"type":"string"}}}},"imagePullSecrets":{"description":"List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.","type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"priorityClassName":{"description":"The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.","type":"string"},"schedulerName":{"description":"The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.","type":"string"},"securityContext":{"description":"Configures pod-level security attributes and common container settings.","type":"object","properties":{"fsGroup":{"type":"integer"},"fsGroupChangePolicy":{"type":"string"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"supplementalGroups":{"type":"array","items":{"type":"integer"}},"sysctls":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"value":{"type":"string"}}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}},"terminationGracePeriodSeconds":{"description":"The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.","type":"integer","minimum":0},"tmpDirSizeLimit":{"description":"Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"tolerations":{"description":"The pod's tolerations.","type":"array","items":{"type":"object","properties":{"effect":{"type":"string"},"key":{"type":"string"},"operator":{"type":"string"},"tolerationSeconds":{"type":"integer"},"value":{"type":"string"}}}},"topologySpreadConstraints":{"description":"The pod's topology spread constraints.","type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"matchLabelKeys":{"type":"array","items":{"type":"string"}},"maxSkew":{"type":"integer"},"minDomains":{"type":"integer"},"nodeAffinityPolicy":{"type":"string"},"nodeTaintsPolicy":{"type":"string"},"topologyKey":{"type":"string"},"whenUnsatisfiable":{"type":"string"}}}}}},"podDisruptionBudget":{"description":"Template for Kafka `PodDisruptionBudget`.","type":"object","properties":{"maxUnavailable":{"description":"Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.","type":"integer","minimum":0},"metadata":{"description":"Metadata to apply to the `PodDisruptionBudgetTemplate` resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"podSet":{"description":"Template for Kafka `StrimziPodSet` resource.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"serviceAccount":{"description":"Template for the Kafka service account.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"statefulset":{"description":"Template for Kafka `StatefulSet`.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"podManagementPolicy":{"description":"PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.","type":"string","enum":["OrderedReady","Parallel"]}}}}},"version":{"description":"The kafka broker version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.","type":"string"}}},"kafkaExporter":{"description":"Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.","type":"object","properties":{"enableSaramaLogging":{"description":"Enable Sarama logging, a Go client library used by the Kafka Exporter.","type":"boolean"},"groupExcludeRegex":{"description":"Regular expression to specify which consumer groups to exclude.","type":"string"},"groupRegex":{"description":"Regular expression to specify which consumer groups to collect. Default value is `.*`.","type":"string"},"image":{"description":"The docker image for the pods.","type":"string"},"livenessProbe":{"description":"Pod liveness check.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"logging":{"description":"Only log messages with the given severity or above. Valid levels: [`info`, `debug`, `trace`]. Default log level is `info`.","type":"string"},"readinessProbe":{"description":"Pod readiness check.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"resources":{"description":"CPU and memory resources to reserve.","type":"object","properties":{"claims":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"limits":{"type":"object","x-kubernetes-preserve-unknown-fields":true},"requests":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"template":{"description":"Customization of deployment templates and pods.","type":"object","properties":{"container":{"description":"Template for the Kafka Exporter container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"deployment":{"description":"Template for Kafka Exporter `Deployment`.","type":"object","properties":{"deploymentStrategy":{"description":"Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.","type":"string","enum":["RollingUpdate","Recreate"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"pod":{"description":"Template for Kafka Exporter `Pods`.","type":"object","properties":{"affinity":{"description":"The pod's affinity rules.","type":"object","properties":{"nodeAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"preference":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"object","properties":{"nodeSelectorTerms":{"type":"array","items":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}}}}}}},"podAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}},"podAntiAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}}}},"enableServiceLinks":{"description":"Indicates whether information about services should be injected into Pod's environment variables.","type":"boolean"},"hostAliases":{"description":"The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.","type":"array","items":{"type":"object","properties":{"hostnames":{"type":"array","items":{"type":"string"}},"ip":{"type":"string"}}}},"imagePullSecrets":{"description":"List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.","type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"priorityClassName":{"description":"The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.","type":"string"},"schedulerName":{"description":"The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.","type":"string"},"securityContext":{"description":"Configures pod-level security attributes and common container settings.","type":"object","properties":{"fsGroup":{"type":"integer"},"fsGroupChangePolicy":{"type":"string"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"supplementalGroups":{"type":"array","items":{"type":"integer"}},"sysctls":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"value":{"type":"string"}}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}},"terminationGracePeriodSeconds":{"description":"The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.","type":"integer","minimum":0},"tmpDirSizeLimit":{"description":"Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"tolerations":{"description":"The pod's tolerations.","type":"array","items":{"type":"object","properties":{"effect":{"type":"string"},"key":{"type":"string"},"operator":{"type":"string"},"tolerationSeconds":{"type":"integer"},"value":{"type":"string"}}}},"topologySpreadConstraints":{"description":"The pod's topology spread constraints.","type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"matchLabelKeys":{"type":"array","items":{"type":"string"}},"maxSkew":{"type":"integer"},"minDomains":{"type":"integer"},"nodeAffinityPolicy":{"type":"string"},"nodeTaintsPolicy":{"type":"string"},"topologyKey":{"type":"string"},"whenUnsatisfiable":{"type":"string"}}}}}},"service":{"description":"Template for Kafka Exporter `Service`.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"serviceAccount":{"description":"Template for the Kafka Exporter service account.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}}}},"topicExcludeRegex":{"description":"Regular expression to specify which topics to exclude.","type":"string"},"topicRegex":{"description":"Regular expression to specify which topics to collect. Default value is `.*`.","type":"string"}}},"maintenanceTimeWindows":{"description":"A list of time windows for maintenance tasks (that is, certificates renewal). Each time window is defined by a cron expression.","type":"array","items":{"type":"string"}},"zookeeper":{"description":"Configuration of the ZooKeeper cluster.","type":"object","required":["replicas","storage"],"properties":{"config":{"description":"The ZooKeeper broker config. Properties with the following prefixes cannot be set: server., dataDir, dataLogDir, clientPort, authProvider, quorum.auth, requireClientAuthScheme, snapshot.trust.empty, standaloneEnabled, reconfigEnabled, 4lw.commands.whitelist, secureClientPort, ssl., serverCnxnFactory, sslQuorum (with the exception of: ssl.protocol, ssl.quorum.protocol, ssl.enabledProtocols, ssl.quorum.enabledProtocols, ssl.ciphersuites, ssl.quorum.ciphersuites, ssl.hostnameVerification, ssl.quorum.hostnameVerification).","type":"object","x-kubernetes-preserve-unknown-fields":true},"image":{"description":"The docker image for the pods.","type":"string"},"jmxOptions":{"description":"JMX Options for Zookeeper nodes.","type":"object","properties":{"authentication":{"description":"Authentication configuration for connecting to the JMX port.","type":"object","required":["type"],"properties":{"type":{"description":"Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.","type":"string","enum":["password"]}}}}},"jvmOptions":{"description":"JVM Options for pods.","type":"object","properties":{"-XX":{"description":"A map of -XX options to the JVM.","type":"object","x-kubernetes-preserve-unknown-fields":true},"-Xms":{"description":"-Xms option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"-Xmx":{"description":"-Xmx option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"gcLoggingEnabled":{"description":"Specifies whether the Garbage Collection logging is enabled. The default is false.","type":"boolean"},"javaSystemProperties":{"description":"A map of additional system properties which will be passed using the `-D` option to the JVM.","type":"array","items":{"type":"object","properties":{"name":{"description":"The system property name.","type":"string"},"value":{"description":"The system property value.","type":"string"}}}}}},"livenessProbe":{"description":"Pod liveness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"logging":{"description":"Logging configuration for ZooKeeper.","type":"object","required":["type"],"properties":{"loggers":{"description":"A Map from logger name to logger level.","type":"object","x-kubernetes-preserve-unknown-fields":true},"type":{"description":"Logging type, must be either 'inline' or 'external'.","type":"string","enum":["inline","external"]},"valueFrom":{"description":"`ConfigMap` entry where the logging configuration is stored. ","type":"object","properties":{"configMapKeyRef":{"description":"Reference to the key in the ConfigMap containing the configuration.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}},"metricsConfig":{"description":"Metrics configuration.","type":"object","required":["type","valueFrom"],"properties":{"type":{"description":"Metrics type. Only 'jmxPrometheusExporter' supported currently.","type":"string","enum":["jmxPrometheusExporter"]},"valueFrom":{"description":"ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.","type":"object","properties":{"configMapKeyRef":{"description":"Reference to the key in the ConfigMap containing the configuration.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}},"readinessProbe":{"description":"Pod readiness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"replicas":{"description":"The number of pods in the cluster.","type":"integer","minimum":1},"resources":{"description":"CPU and memory resources to reserve.","type":"object","properties":{"claims":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"limits":{"type":"object","x-kubernetes-preserve-unknown-fields":true},"requests":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"storage":{"description":"Storage configuration (disk). Cannot be updated.","type":"object","required":["type"],"properties":{"class":{"description":"The storage class to use for dynamic volume allocation.","type":"string"},"deleteClaim":{"description":"Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.","type":"boolean"},"id":{"description":"Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.","type":"integer","minimum":0},"overrides":{"description":"Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.","type":"array","items":{"type":"object","properties":{"broker":{"description":"Id of the kafka broker (broker identifier).","type":"integer"},"class":{"description":"The storage class to use for dynamic volume allocation for this broker.","type":"string"}}}},"selector":{"description":"Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.","type":"object","x-kubernetes-preserve-unknown-fields":true},"size":{"description":"When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.","type":"string"},"sizeLimit":{"description":"When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"type":{"description":"Storage type, must be either 'ephemeral' or 'persistent-claim'.","type":"string","enum":["ephemeral","persistent-claim"]}}},"template":{"description":"Template for ZooKeeper cluster resources. The template allows users to specify how the Kubernetes resources are generated.","type":"object","properties":{"clientService":{"description":"Template for ZooKeeper client `Service`.","type":"object","properties":{"ipFamilies":{"description":"Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.","type":"array","items":{"type":"string","enum":["IPv4","IPv6"]}},"ipFamilyPolicy":{"description":"Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.","type":"string","enum":["SingleStack","PreferDualStack","RequireDualStack"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"jmxSecret":{"description":"Template for Secret of the Zookeeper Cluster JMX authentication.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"nodesService":{"description":"Template for ZooKeeper nodes `Service`.","type":"object","properties":{"ipFamilies":{"description":"Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.","type":"array","items":{"type":"string","enum":["IPv4","IPv6"]}},"ipFamilyPolicy":{"description":"Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.","type":"string","enum":["SingleStack","PreferDualStack","RequireDualStack"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"persistentVolumeClaim":{"description":"Template for all ZooKeeper `PersistentVolumeClaims`.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"pod":{"description":"Template for ZooKeeper `Pods`.","type":"object","properties":{"affinity":{"description":"The pod's affinity rules.","type":"object","properties":{"nodeAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"preference":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"object","properties":{"nodeSelectorTerms":{"type":"array","items":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}}}}}}},"podAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}},"podAntiAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}}}},"enableServiceLinks":{"description":"Indicates whether information about services should be injected into Pod's environment variables.","type":"boolean"},"hostAliases":{"description":"The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.","type":"array","items":{"type":"object","properties":{"hostnames":{"type":"array","items":{"type":"string"}},"ip":{"type":"string"}}}},"imagePullSecrets":{"description":"List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.","type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"priorityClassName":{"description":"The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.","type":"string"},"schedulerName":{"description":"The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.","type":"string"},"securityContext":{"description":"Configures pod-level security attributes and common container settings.","type":"object","properties":{"fsGroup":{"type":"integer"},"fsGroupChangePolicy":{"type":"string"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"supplementalGroups":{"type":"array","items":{"type":"integer"}},"sysctls":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"value":{"type":"string"}}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}},"terminationGracePeriodSeconds":{"description":"The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.","type":"integer","minimum":0},"tmpDirSizeLimit":{"description":"Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"tolerations":{"description":"The pod's tolerations.","type":"array","items":{"type":"object","properties":{"effect":{"type":"string"},"key":{"type":"string"},"operator":{"type":"string"},"tolerationSeconds":{"type":"integer"},"value":{"type":"string"}}}},"topologySpreadConstraints":{"description":"The pod's topology spread constraints.","type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"matchLabelKeys":{"type":"array","items":{"type":"string"}},"maxSkew":{"type":"integer"},"minDomains":{"type":"integer"},"nodeAffinityPolicy":{"type":"string"},"nodeTaintsPolicy":{"type":"string"},"topologyKey":{"type":"string"},"whenUnsatisfiable":{"type":"string"}}}}}},"podDisruptionBudget":{"description":"Template for ZooKeeper `PodDisruptionBudget`.","type":"object","properties":{"maxUnavailable":{"description":"Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.","type":"integer","minimum":0},"metadata":{"description":"Metadata to apply to the `PodDisruptionBudgetTemplate` resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"podSet":{"description":"Template for ZooKeeper `StrimziPodSet` resource.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"serviceAccount":{"description":"Template for the ZooKeeper service account.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"statefulset":{"description":"Template for ZooKeeper `StatefulSet`.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"podManagementPolicy":{"description":"PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.","type":"string","enum":["OrderedReady","Parallel"]}}},"zookeeperContainer":{"description":"Template for the ZooKeeper container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}}}}}}}},"status":{"description":"The status of the Kafka and ZooKeeper clusters, and Topic Operator.","type":"object","properties":{"clusterId":{"description":"Kafka cluster Id.","type":"string"},"conditions":{"description":"List of status conditions.","type":"array","items":{"type":"object","properties":{"lastTransitionTime":{"description":"Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.","type":"string"},"message":{"description":"Human-readable message indicating details about the condition's last transition.","type":"string"},"reason":{"description":"The reason for the condition's last transition (a single word in CamelCase).","type":"string"},"status":{"description":"The status of the condition, either True, False or Unknown.","type":"string"},"type":{"description":"The unique identifier of a condition, used to distinguish between other conditions in the resource.","type":"string"}}}},"kafkaNodePools":{"description":"List of the KafkaNodePools used by this Kafka cluster.","type":"array","items":{"type":"object","properties":{"name":{"description":"The name of the KafkaNodePool used by this Kafka resource.","type":"string"}}}},"listeners":{"description":"Addresses of the internal and external listeners.","type":"array","items":{"type":"object","properties":{"addresses":{"description":"A list of the addresses for this listener.","type":"array","items":{"type":"object","properties":{"host":{"description":"The DNS name or IP address of the Kafka bootstrap service.","type":"string"},"port":{"description":"The port of the Kafka bootstrap service.","type":"integer"}}}},"bootstrapServers":{"description":"A comma-separated list of `host:port` pairs for connecting to the Kafka cluster using this listener.","type":"string"},"certificates":{"description":"A list of TLS certificates which can be used to verify the identity of the server when connecting to the given listener. Set only for `tls` and `external` listeners.","type":"array","items":{"type":"string"}},"name":{"description":"The name of the listener.","type":"string"},"type":{"description":"*The `type` property has been deprecated, and should now be configured using `name`.* The name of the listener.","type":"string"}}}},"observedGeneration":{"description":"The generation of the CRD that was last reconciled by the operator.","type":"integer"}}}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"Kafka","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaBridge":{"type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"}]},"spec":{"description":"The specification of the Kafka Bridge.","type":"object","required":["bootstrapServers"],"properties":{"adminClient":{"description":"Kafka AdminClient related configuration.","type":"object","properties":{"config":{"description":"The Kafka AdminClient configuration used for AdminClient instances created by the bridge.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"authentication":{"description":"Authentication configuration for connecting to the cluster.","type":"object","required":["type"],"properties":{"accessToken":{"description":"Link to Kubernetes Secret containing the access token which was obtained from the authorization server.","type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}},"accessTokenIsJwt":{"description":"Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.","type":"boolean"},"audience":{"description":"OAuth audience to use when authenticating against the authorization server. Some authorization servers require the audience to be explicitly set. The possible values depend on how the authorization server is configured. By default, `audience` is not specified when performing the token endpoint request.","type":"string"},"certificateAndKey":{"description":"Reference to the `Secret` which holds the certificate and private key pair.","type":"object","required":["certificate","key","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"key":{"description":"The name of the private key in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}},"clientId":{"description":"OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.","type":"string"},"clientSecret":{"description":"Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.","type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}},"connectTimeoutSeconds":{"description":"The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.","type":"integer"},"disableTlsHostnameVerification":{"description":"Enable or disable TLS hostname verification. Default value is `false`.","type":"boolean"},"enableMetrics":{"description":"Enable or disable OAuth metrics. Default value is `false`.","type":"boolean"},"httpRetries":{"description":"The maximum number of retries to attempt if an initial HTTP request fails. If not set, the default is to not attempt any retries.","type":"integer"},"httpRetryPauseMs":{"description":"The pause to take before retrying a failed HTTP request. If not set, the default is to not pause at all but to immediately repeat a request.","type":"integer"},"maxTokenExpirySeconds":{"description":"Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.","type":"integer"},"passwordSecret":{"description":"Reference to the `Secret` which holds the password.","type":"object","required":["password","secretName"],"properties":{"password":{"description":"The name of the key in the Secret under which the password is stored.","type":"string"},"secretName":{"description":"The name of the Secret containing the password.","type":"string"}}},"readTimeoutSeconds":{"description":"The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.","type":"integer"},"refreshToken":{"description":"Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.","type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}},"scope":{"description":"OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.","type":"string"},"tlsTrustedCertificates":{"description":"Trusted certificates for TLS connection to the OAuth server.","type":"array","items":{"type":"object","required":["certificate","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}}},"tokenEndpointUri":{"description":"Authorization server token endpoint URI.","type":"string"},"type":{"description":"Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.","type":"string","enum":["tls","scram-sha-256","scram-sha-512","plain","oauth"]},"username":{"description":"Username used for the authentication.","type":"string"}}},"bootstrapServers":{"description":"A list of host:port pairs for establishing the initial connection to the Kafka cluster.","type":"string"},"clientRackInitImage":{"description":"The image of the init container used for initializing the `client.rack`.","type":"string"},"consumer":{"description":"Kafka consumer related configuration.","type":"object","properties":{"config":{"description":"The Kafka consumer configuration used for consumer instances created by the bridge. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, group.id, sasl., security. (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"enableMetrics":{"description":"Enable the metrics for the Kafka Bridge. Default is false.","type":"boolean"},"http":{"description":"The HTTP related configuration.","type":"object","properties":{"cors":{"description":"CORS configuration for the HTTP Bridge.","type":"object","required":["allowedOrigins","allowedMethods"],"properties":{"allowedMethods":{"description":"List of allowed HTTP methods.","type":"array","items":{"type":"string"}},"allowedOrigins":{"description":"List of allowed origins. Java regular expressions can be used.","type":"array","items":{"type":"string"}}}},"port":{"description":"The port which is the server listening on.","type":"integer","minimum":1023}}},"image":{"description":"The docker image for the pods.","type":"string"},"jvmOptions":{"description":"**Currently not supported** JVM Options for pods.","type":"object","properties":{"-XX":{"description":"A map of -XX options to the JVM.","type":"object","x-kubernetes-preserve-unknown-fields":true},"-Xms":{"description":"-Xms option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"-Xmx":{"description":"-Xmx option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"gcLoggingEnabled":{"description":"Specifies whether the Garbage Collection logging is enabled. The default is false.","type":"boolean"},"javaSystemProperties":{"description":"A map of additional system properties which will be passed using the `-D` option to the JVM.","type":"array","items":{"type":"object","properties":{"name":{"description":"The system property name.","type":"string"},"value":{"description":"The system property value.","type":"string"}}}}}},"livenessProbe":{"description":"Pod liveness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"logging":{"description":"Logging configuration for Kafka Bridge.","type":"object","required":["type"],"properties":{"loggers":{"description":"A Map from logger name to logger level.","type":"object","x-kubernetes-preserve-unknown-fields":true},"type":{"description":"Logging type, must be either 'inline' or 'external'.","type":"string","enum":["inline","external"]},"valueFrom":{"description":"`ConfigMap` entry where the logging configuration is stored. ","type":"object","properties":{"configMapKeyRef":{"description":"Reference to the key in the ConfigMap containing the configuration.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}},"producer":{"description":"Kafka producer related configuration.","type":"object","properties":{"config":{"description":"The Kafka producer configuration used for producer instances created by the bridge. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, sasl., security. (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"rack":{"description":"Configuration of the node label which will be used as the client.rack consumer configuration.","type":"object","required":["topologyKey"],"properties":{"topologyKey":{"description":"A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set a broker's `broker.rack` config, and the `client.rack` config for Kafka Connect or MirrorMaker 2.","type":"string"}}},"readinessProbe":{"description":"Pod readiness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"replicas":{"description":"The number of pods in the `Deployment`.  Defaults to `1`.","type":"integer","minimum":0},"resources":{"description":"CPU and memory resources to reserve.","type":"object","properties":{"claims":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"limits":{"type":"object","x-kubernetes-preserve-unknown-fields":true},"requests":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"template":{"description":"Template for Kafka Bridge resources. The template allows users to specify how a `Deployment` and `Pod` is generated.","type":"object","properties":{"apiService":{"description":"Template for Kafka Bridge API `Service`.","type":"object","properties":{"ipFamilies":{"description":"Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.","type":"array","items":{"type":"string","enum":["IPv4","IPv6"]}},"ipFamilyPolicy":{"description":"Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.","type":"string","enum":["SingleStack","PreferDualStack","RequireDualStack"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"bridgeContainer":{"description":"Template for the Kafka Bridge container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"clusterRoleBinding":{"description":"Template for the Kafka Bridge ClusterRoleBinding.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"deployment":{"description":"Template for Kafka Bridge `Deployment`.","type":"object","properties":{"deploymentStrategy":{"description":"Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.","type":"string","enum":["RollingUpdate","Recreate"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"initContainer":{"description":"Template for the Kafka Bridge init container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"pod":{"description":"Template for Kafka Bridge `Pods`.","type":"object","properties":{"affinity":{"description":"The pod's affinity rules.","type":"object","properties":{"nodeAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"preference":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"object","properties":{"nodeSelectorTerms":{"type":"array","items":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}}}}}}},"podAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}},"podAntiAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}}}},"enableServiceLinks":{"description":"Indicates whether information about services should be injected into Pod's environment variables.","type":"boolean"},"hostAliases":{"description":"The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.","type":"array","items":{"type":"object","properties":{"hostnames":{"type":"array","items":{"type":"string"}},"ip":{"type":"string"}}}},"imagePullSecrets":{"description":"List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.","type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"priorityClassName":{"description":"The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.","type":"string"},"schedulerName":{"description":"The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.","type":"string"},"securityContext":{"description":"Configures pod-level security attributes and common container settings.","type":"object","properties":{"fsGroup":{"type":"integer"},"fsGroupChangePolicy":{"type":"string"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"supplementalGroups":{"type":"array","items":{"type":"integer"}},"sysctls":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"value":{"type":"string"}}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}},"terminationGracePeriodSeconds":{"description":"The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.","type":"integer","minimum":0},"tmpDirSizeLimit":{"description":"Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"tolerations":{"description":"The pod's tolerations.","type":"array","items":{"type":"object","properties":{"effect":{"type":"string"},"key":{"type":"string"},"operator":{"type":"string"},"tolerationSeconds":{"type":"integer"},"value":{"type":"string"}}}},"topologySpreadConstraints":{"description":"The pod's topology spread constraints.","type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"matchLabelKeys":{"type":"array","items":{"type":"string"}},"maxSkew":{"type":"integer"},"minDomains":{"type":"integer"},"nodeAffinityPolicy":{"type":"string"},"nodeTaintsPolicy":{"type":"string"},"topologyKey":{"type":"string"},"whenUnsatisfiable":{"type":"string"}}}}}},"podDisruptionBudget":{"description":"Template for Kafka Bridge `PodDisruptionBudget`.","type":"object","properties":{"maxUnavailable":{"description":"Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.","type":"integer","minimum":0},"metadata":{"description":"Metadata to apply to the `PodDisruptionBudgetTemplate` resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"serviceAccount":{"description":"Template for the Kafka Bridge service account.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}}}},"tls":{"description":"TLS configuration for connecting Kafka Bridge to the cluster.","type":"object","properties":{"trustedCertificates":{"description":"Trusted certificates for TLS connection.","type":"array","items":{"type":"object","required":["certificate","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}}}}},"tracing":{"description":"The configuration of tracing in Kafka Bridge.","type":"object","required":["type"],"properties":{"type":{"description":"Type of the tracing used. Currently the only supported types are `jaeger` for OpenTracing (Jaeger) tracing and `opentelemetry` for OpenTelemetry tracing. The OpenTracing (Jaeger) tracing is deprecated.","type":"string","enum":["jaeger","opentelemetry"]}}}}},"status":{"description":"The status of the Kafka Bridge.","type":"object","properties":{"conditions":{"description":"List of status conditions.","type":"array","items":{"type":"object","properties":{"lastTransitionTime":{"description":"Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.","type":"string"},"message":{"description":"Human-readable message indicating details about the condition's last transition.","type":"string"},"reason":{"description":"The reason for the condition's last transition (a single word in CamelCase).","type":"string"},"status":{"description":"The status of the condition, either True, False or Unknown.","type":"string"},"type":{"description":"The unique identifier of a condition, used to distinguish between other conditions in the resource.","type":"string"}}}},"labelSelector":{"description":"Label selector for pods providing this resource.","type":"string"},"observedGeneration":{"description":"The generation of the CRD that was last reconciled by the operator.","type":"integer"},"replicas":{"description":"The current number of pods being used to provide this resource.","type":"integer"},"url":{"description":"The URL at which external client applications can access the Kafka Bridge.","type":"string"}}}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaBridge","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaBridgeList":{"description":"KafkaBridgeList is a list of KafkaBridge","type":"object","required":["items"],"properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"items":{"description":"List of kafkabridges. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md","type":"array","items":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaBridge"}},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"}]}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaBridgeList","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaConnect":{"type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"}]},"spec":{"description":"The specification of the Kafka Connect cluster.","type":"object","required":["bootstrapServers"],"properties":{"authentication":{"description":"Authentication configuration for Kafka Connect.","type":"object","required":["type"],"properties":{"accessToken":{"description":"Link to Kubernetes Secret containing the access token which was obtained from the authorization server.","type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}},"accessTokenIsJwt":{"description":"Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.","type":"boolean"},"audience":{"description":"OAuth audience to use when authenticating against the authorization server. Some authorization servers require the audience to be explicitly set. The possible values depend on how the authorization server is configured. By default, `audience` is not specified when performing the token endpoint request.","type":"string"},"certificateAndKey":{"description":"Reference to the `Secret` which holds the certificate and private key pair.","type":"object","required":["certificate","key","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"key":{"description":"The name of the private key in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}},"clientId":{"description":"OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.","type":"string"},"clientSecret":{"description":"Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.","type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}},"connectTimeoutSeconds":{"description":"The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.","type":"integer"},"disableTlsHostnameVerification":{"description":"Enable or disable TLS hostname verification. Default value is `false`.","type":"boolean"},"enableMetrics":{"description":"Enable or disable OAuth metrics. Default value is `false`.","type":"boolean"},"httpRetries":{"description":"The maximum number of retries to attempt if an initial HTTP request fails. If not set, the default is to not attempt any retries.","type":"integer"},"httpRetryPauseMs":{"description":"The pause to take before retrying a failed HTTP request. If not set, the default is to not pause at all but to immediately repeat a request.","type":"integer"},"maxTokenExpirySeconds":{"description":"Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.","type":"integer"},"passwordSecret":{"description":"Reference to the `Secret` which holds the password.","type":"object","required":["password","secretName"],"properties":{"password":{"description":"The name of the key in the Secret under which the password is stored.","type":"string"},"secretName":{"description":"The name of the Secret containing the password.","type":"string"}}},"readTimeoutSeconds":{"description":"The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.","type":"integer"},"refreshToken":{"description":"Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.","type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}},"scope":{"description":"OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.","type":"string"},"tlsTrustedCertificates":{"description":"Trusted certificates for TLS connection to the OAuth server.","type":"array","items":{"type":"object","required":["certificate","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}}},"tokenEndpointUri":{"description":"Authorization server token endpoint URI.","type":"string"},"type":{"description":"Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.","type":"string","enum":["tls","scram-sha-256","scram-sha-512","plain","oauth"]},"username":{"description":"Username used for the authentication.","type":"string"}}},"bootstrapServers":{"description":"Bootstrap servers to connect to. This should be given as a comma separated list of _\u003chostname\u003e_:_\u003cport\u003e_ pairs.","type":"string"},"build":{"description":"Configures how the Connect container image should be built. Optional.","type":"object","required":["output","plugins"],"properties":{"output":{"description":"Configures where should the newly built image be stored. Required.","type":"object","required":["image","type"],"properties":{"additionalKanikoOptions":{"description":"Configures additional options which will be passed to the Kaniko executor when building the new Connect image. Allowed options are: --customPlatform, --insecure, --insecure-pull, --insecure-registry, --log-format, --log-timestamp, --registry-mirror, --reproducible, --single-snapshot, --skip-tls-verify, --skip-tls-verify-pull, --skip-tls-verify-registry, --verbosity, --snapshotMode, --use-new-run. These options will be used only on Kubernetes where the Kaniko executor is used. They will be ignored on OpenShift. The options are described in the link:https://github.com/GoogleContainerTools/kaniko[Kaniko GitHub repository^]. Changing this field does not trigger new build of the Kafka Connect image.","type":"array","items":{"type":"string"}},"image":{"description":"The name of the image which will be built. Required.","type":"string"},"pushSecret":{"description":"Container Registry Secret with the credentials for pushing the newly built image.","type":"string"},"type":{"description":"Output type. Must be either `docker` for pushing the newly build image to Docker compatible registry or `imagestream` for pushing the image to OpenShift ImageStream. Required.","type":"string","enum":["docker","imagestream"]}}},"plugins":{"description":"List of connector plugins which should be added to the Kafka Connect. Required.","type":"array","items":{"type":"object","required":["name","artifacts"],"properties":{"artifacts":{"description":"List of artifacts which belong to this connector plugin. Required.","type":"array","items":{"type":"object","required":["type"],"properties":{"artifact":{"description":"Maven artifact id. Applicable to the `maven` artifact type only.","type":"string"},"fileName":{"description":"Name under which the artifact will be stored.","type":"string"},"group":{"description":"Maven group id. Applicable to the `maven` artifact type only.","type":"string"},"insecure":{"description":"By default, connections using TLS are verified to check they are secure. The server certificate used must be valid, trusted, and contain the server name. By setting this option to `true`, all TLS verification is disabled and the artifact will be downloaded, even when the server is considered insecure.","type":"boolean"},"repository":{"description":"Maven repository to download the artifact from. Applicable to the `maven` artifact type only.","type":"string"},"sha512sum":{"description":"SHA512 checksum of the artifact. Optional. If specified, the checksum will be verified while building the new container. If not specified, the downloaded artifact will not be verified. Not applicable to the `maven` artifact type. ","type":"string"},"type":{"description":"Artifact type. Currently, the supported artifact types are `tgz`, `jar`, `zip`, `other` and `maven`.","type":"string","enum":["jar","tgz","zip","maven","other"]},"url":{"description":"URL of the artifact which will be downloaded. Strimzi does not do any security scanning of the downloaded artifacts. For security reasons, you should first verify the artifacts manually and configure the checksum verification to make sure the same artifact is used in the automated build. Required for `jar`, `zip`, `tgz` and `other` artifacts. Not applicable to the `maven` artifact type.","type":"string","pattern":"^(https?|ftp)://[-a-zA-Z0-9+\u0026@#/%?=~_|!:,.;]*[-a-zA-Z0-9+\u0026@#/%=~_|]$"},"version":{"description":"Maven version number. Applicable to the `maven` artifact type only.","type":"string"}}}},"name":{"description":"The unique name of the connector plugin. Will be used to generate the path where the connector artifacts will be stored. The name has to be unique within the KafkaConnect resource. The name has to follow the following pattern: `^[a-z][-_a-z0-9]*[a-z]$`. Required.","type":"string","pattern":"^[a-z0-9][-_a-z0-9]*[a-z0-9]$"}}}},"resources":{"description":"CPU and memory resources to reserve for the build.","type":"object","properties":{"claims":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"limits":{"type":"object","x-kubernetes-preserve-unknown-fields":true},"requests":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"clientRackInitImage":{"description":"The image of the init container used for initializing the `client.rack`.","type":"string"},"config":{"description":"The Kafka Connect configuration. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).","type":"object","x-kubernetes-preserve-unknown-fields":true},"externalConfiguration":{"description":"Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.","type":"object","properties":{"env":{"description":"Makes data from a Secret or ConfigMap available in the Kafka Connect pods as environment variables.","type":"array","items":{"type":"object","required":["name","valueFrom"],"properties":{"name":{"description":"Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.","type":"string"},"valueFrom":{"description":"Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.","type":"object","properties":{"configMapKeyRef":{"description":"Reference to a key in a ConfigMap.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}},"secretKeyRef":{"description":"Reference to a key in a Secret.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}}},"volumes":{"description":"Makes data from a Secret or ConfigMap available in the Kafka Connect pods as volumes.","type":"array","items":{"type":"object","required":["name"],"properties":{"configMap":{"description":"Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.","type":"object","properties":{"defaultMode":{"type":"integer"},"items":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"mode":{"type":"integer"},"path":{"type":"string"}}}},"name":{"type":"string"},"optional":{"type":"boolean"}}},"name":{"description":"Name of the volume which will be added to the Kafka Connect pods.","type":"string"},"secret":{"description":"Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.","type":"object","properties":{"defaultMode":{"type":"integer"},"items":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"mode":{"type":"integer"},"path":{"type":"string"}}}},"optional":{"type":"boolean"},"secretName":{"type":"string"}}}}}}}},"image":{"description":"The docker image for the pods.","type":"string"},"jmxOptions":{"description":"JMX Options.","type":"object","properties":{"authentication":{"description":"Authentication configuration for connecting to the JMX port.","type":"object","required":["type"],"properties":{"type":{"description":"Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.","type":"string","enum":["password"]}}}}},"jvmOptions":{"description":"JVM Options for pods.","type":"object","properties":{"-XX":{"description":"A map of -XX options to the JVM.","type":"object","x-kubernetes-preserve-unknown-fields":true},"-Xms":{"description":"-Xms option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"-Xmx":{"description":"-Xmx option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"gcLoggingEnabled":{"description":"Specifies whether the Garbage Collection logging is enabled. The default is false.","type":"boolean"},"javaSystemProperties":{"description":"A map of additional system properties which will be passed using the `-D` option to the JVM.","type":"array","items":{"type":"object","properties":{"name":{"description":"The system property name.","type":"string"},"value":{"description":"The system property value.","type":"string"}}}}}},"livenessProbe":{"description":"Pod liveness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"logging":{"description":"Logging configuration for Kafka Connect.","type":"object","required":["type"],"properties":{"loggers":{"description":"A Map from logger name to logger level.","type":"object","x-kubernetes-preserve-unknown-fields":true},"type":{"description":"Logging type, must be either 'inline' or 'external'.","type":"string","enum":["inline","external"]},"valueFrom":{"description":"`ConfigMap` entry where the logging configuration is stored. ","type":"object","properties":{"configMapKeyRef":{"description":"Reference to the key in the ConfigMap containing the configuration.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}},"metricsConfig":{"description":"Metrics configuration.","type":"object","required":["type","valueFrom"],"properties":{"type":{"description":"Metrics type. Only 'jmxPrometheusExporter' supported currently.","type":"string","enum":["jmxPrometheusExporter"]},"valueFrom":{"description":"ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.","type":"object","properties":{"configMapKeyRef":{"description":"Reference to the key in the ConfigMap containing the configuration.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}},"rack":{"description":"Configuration of the node label which will be used as the `client.rack` consumer configuration.","type":"object","required":["topologyKey"],"properties":{"topologyKey":{"description":"A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set a broker's `broker.rack` config, and the `client.rack` config for Kafka Connect or MirrorMaker 2.","type":"string"}}},"readinessProbe":{"description":"Pod readiness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"replicas":{"description":"The number of pods in the Kafka Connect group. Defaults to `3`.","type":"integer"},"resources":{"description":"The maximum limits for CPU and memory resources and the requested initial resources.","type":"object","properties":{"claims":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"limits":{"type":"object","x-kubernetes-preserve-unknown-fields":true},"requests":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"template":{"description":"Template for Kafka Connect and Kafka Mirror Maker 2 resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.","type":"object","properties":{"apiService":{"description":"Template for Kafka Connect API `Service`.","type":"object","properties":{"ipFamilies":{"description":"Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.","type":"array","items":{"type":"string","enum":["IPv4","IPv6"]}},"ipFamilyPolicy":{"description":"Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.","type":"string","enum":["SingleStack","PreferDualStack","RequireDualStack"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"buildConfig":{"description":"Template for the Kafka Connect BuildConfig used to build new container images. The BuildConfig is used only on OpenShift.","type":"object","properties":{"metadata":{"description":"Metadata to apply to the `PodDisruptionBudgetTemplate` resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"pullSecret":{"description":"Container Registry Secret with the credentials for pulling the base image.","type":"string"}}},"buildContainer":{"description":"Template for the Kafka Connect Build container. The build container is used only on Kubernetes.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"buildPod":{"description":"Template for Kafka Connect Build `Pods`. The build pod is used only on Kubernetes.","type":"object","properties":{"affinity":{"description":"The pod's affinity rules.","type":"object","properties":{"nodeAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"preference":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"object","properties":{"nodeSelectorTerms":{"type":"array","items":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}}}}}}},"podAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}},"podAntiAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}}}},"enableServiceLinks":{"description":"Indicates whether information about services should be injected into Pod's environment variables.","type":"boolean"},"hostAliases":{"description":"The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.","type":"array","items":{"type":"object","properties":{"hostnames":{"type":"array","items":{"type":"string"}},"ip":{"type":"string"}}}},"imagePullSecrets":{"description":"List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.","type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"priorityClassName":{"description":"The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.","type":"string"},"schedulerName":{"description":"The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.","type":"string"},"securityContext":{"description":"Configures pod-level security attributes and common container settings.","type":"object","properties":{"fsGroup":{"type":"integer"},"fsGroupChangePolicy":{"type":"string"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"supplementalGroups":{"type":"array","items":{"type":"integer"}},"sysctls":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"value":{"type":"string"}}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}},"terminationGracePeriodSeconds":{"description":"The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.","type":"integer","minimum":0},"tmpDirSizeLimit":{"description":"Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"tolerations":{"description":"The pod's tolerations.","type":"array","items":{"type":"object","properties":{"effect":{"type":"string"},"key":{"type":"string"},"operator":{"type":"string"},"tolerationSeconds":{"type":"integer"},"value":{"type":"string"}}}},"topologySpreadConstraints":{"description":"The pod's topology spread constraints.","type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"matchLabelKeys":{"type":"array","items":{"type":"string"}},"maxSkew":{"type":"integer"},"minDomains":{"type":"integer"},"nodeAffinityPolicy":{"type":"string"},"nodeTaintsPolicy":{"type":"string"},"topologyKey":{"type":"string"},"whenUnsatisfiable":{"type":"string"}}}}}},"buildServiceAccount":{"description":"Template for the Kafka Connect Build service account.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"clusterRoleBinding":{"description":"Template for the Kafka Connect ClusterRoleBinding.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"connectContainer":{"description":"Template for the Kafka Connect container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"deployment":{"description":"Template for Kafka Connect `Deployment`.","type":"object","properties":{"deploymentStrategy":{"description":"Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.","type":"string","enum":["RollingUpdate","Recreate"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"headlessService":{"description":"Template for Kafka Connect headless `Service`.","type":"object","properties":{"ipFamilies":{"description":"Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.","type":"array","items":{"type":"string","enum":["IPv4","IPv6"]}},"ipFamilyPolicy":{"description":"Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.","type":"string","enum":["SingleStack","PreferDualStack","RequireDualStack"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"initContainer":{"description":"Template for the Kafka init container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"jmxSecret":{"description":"Template for Secret of the Kafka Connect Cluster JMX authentication.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"pod":{"description":"Template for Kafka Connect `Pods`.","type":"object","properties":{"affinity":{"description":"The pod's affinity rules.","type":"object","properties":{"nodeAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"preference":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"object","properties":{"nodeSelectorTerms":{"type":"array","items":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}}}}}}},"podAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}},"podAntiAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}}}},"enableServiceLinks":{"description":"Indicates whether information about services should be injected into Pod's environment variables.","type":"boolean"},"hostAliases":{"description":"The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.","type":"array","items":{"type":"object","properties":{"hostnames":{"type":"array","items":{"type":"string"}},"ip":{"type":"string"}}}},"imagePullSecrets":{"description":"List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.","type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"priorityClassName":{"description":"The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.","type":"string"},"schedulerName":{"description":"The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.","type":"string"},"securityContext":{"description":"Configures pod-level security attributes and common container settings.","type":"object","properties":{"fsGroup":{"type":"integer"},"fsGroupChangePolicy":{"type":"string"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"supplementalGroups":{"type":"array","items":{"type":"integer"}},"sysctls":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"value":{"type":"string"}}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}},"terminationGracePeriodSeconds":{"description":"The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.","type":"integer","minimum":0},"tmpDirSizeLimit":{"description":"Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"tolerations":{"description":"The pod's tolerations.","type":"array","items":{"type":"object","properties":{"effect":{"type":"string"},"key":{"type":"string"},"operator":{"type":"string"},"tolerationSeconds":{"type":"integer"},"value":{"type":"string"}}}},"topologySpreadConstraints":{"description":"The pod's topology spread constraints.","type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"matchLabelKeys":{"type":"array","items":{"type":"string"}},"maxSkew":{"type":"integer"},"minDomains":{"type":"integer"},"nodeAffinityPolicy":{"type":"string"},"nodeTaintsPolicy":{"type":"string"},"topologyKey":{"type":"string"},"whenUnsatisfiable":{"type":"string"}}}}}},"podDisruptionBudget":{"description":"Template for Kafka Connect `PodDisruptionBudget`.","type":"object","properties":{"maxUnavailable":{"description":"Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.","type":"integer","minimum":0},"metadata":{"description":"Metadata to apply to the `PodDisruptionBudgetTemplate` resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"podSet":{"description":"Template for Kafka Connect `StrimziPodSet` resource.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"serviceAccount":{"description":"Template for the Kafka Connect service account.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}}}},"tls":{"description":"TLS configuration.","type":"object","properties":{"trustedCertificates":{"description":"Trusted certificates for TLS connection.","type":"array","items":{"type":"object","required":["certificate","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}}}}},"tracing":{"description":"The configuration of tracing in Kafka Connect.","type":"object","required":["type"],"properties":{"type":{"description":"Type of the tracing used. Currently the only supported types are `jaeger` for OpenTracing (Jaeger) tracing and `opentelemetry` for OpenTelemetry tracing. The OpenTracing (Jaeger) tracing is deprecated.","type":"string","enum":["jaeger","opentelemetry"]}}},"version":{"description":"The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.","type":"string"}}},"status":{"description":"The status of the Kafka Connect cluster.","type":"object","properties":{"conditions":{"description":"List of status conditions.","type":"array","items":{"type":"object","properties":{"lastTransitionTime":{"description":"Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.","type":"string"},"message":{"description":"Human-readable message indicating details about the condition's last transition.","type":"string"},"reason":{"description":"The reason for the condition's last transition (a single word in CamelCase).","type":"string"},"status":{"description":"The status of the condition, either True, False or Unknown.","type":"string"},"type":{"description":"The unique identifier of a condition, used to distinguish between other conditions in the resource.","type":"string"}}}},"connectorPlugins":{"description":"The list of connector plugins available in this Kafka Connect deployment.","type":"array","items":{"type":"object","properties":{"class":{"description":"The class of the connector plugin.","type":"string"},"type":{"description":"The type of the connector plugin. The available types are `sink` and `source`.","type":"string"},"version":{"description":"The version of the connector plugin.","type":"string"}}}},"labelSelector":{"description":"Label selector for pods providing this resource.","type":"string"},"observedGeneration":{"description":"The generation of the CRD that was last reconciled by the operator.","type":"integer"},"replicas":{"description":"The current number of pods being used to provide this resource.","type":"integer"},"url":{"description":"The URL of the REST API endpoint for managing and monitoring Kafka Connect connectors.","type":"string"}}}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaConnect","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaConnectList":{"description":"KafkaConnectList is a list of KafkaConnect","type":"object","required":["items"],"properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"items":{"description":"List of kafkaconnects. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md","type":"array","items":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnect"}},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"}]}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaConnectList","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaConnector":{"type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"}]},"spec":{"description":"The specification of the Kafka Connector.","type":"object","properties":{"autoRestart":{"description":"Automatic restart of connector and tasks configuration.","type":"object","properties":{"enabled":{"description":"Whether automatic restart for failed connectors and tasks should be enabled or disabled.","type":"boolean"}}},"class":{"description":"The Class for the Kafka Connector.","type":"string"},"config":{"description":"The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.","type":"object","x-kubernetes-preserve-unknown-fields":true},"pause":{"description":"Whether the connector should be paused. Defaults to false.","type":"boolean"},"tasksMax":{"description":"The maximum number of tasks for the Kafka Connector.","type":"integer","minimum":1}}},"status":{"description":"The status of the Kafka Connector.","type":"object","properties":{"autoRestart":{"description":"The auto restart status.","type":"object","properties":{"connectorName":{"description":"The name of the connector being restarted.","type":"string"},"count":{"description":"The number of times the connector or task is restarted.","type":"integer"},"lastRestartTimestamp":{"description":"The last time the automatic restart was attempted. The required format is 'yyyy-MM-ddTHH:mm:ssZ' in the UTC time zone.","type":"string"}}},"conditions":{"description":"List of status conditions.","type":"array","items":{"type":"object","properties":{"lastTransitionTime":{"description":"Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.","type":"string"},"message":{"description":"Human-readable message indicating details about the condition's last transition.","type":"string"},"reason":{"description":"The reason for the condition's last transition (a single word in CamelCase).","type":"string"},"status":{"description":"The status of the condition, either True, False or Unknown.","type":"string"},"type":{"description":"The unique identifier of a condition, used to distinguish between other conditions in the resource.","type":"string"}}}},"connectorStatus":{"description":"The connector status, as reported by the Kafka Connect REST API.","type":"object","x-kubernetes-preserve-unknown-fields":true},"observedGeneration":{"description":"The generation of the CRD that was last reconciled by the operator.","type":"integer"},"tasksMax":{"description":"The maximum number of tasks for the Kafka Connector.","type":"integer"},"topics":{"description":"The list of topics used by the Kafka Connector.","type":"array","items":{"type":"string"}}}}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaConnector","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaConnectorList":{"description":"KafkaConnectorList is a list of KafkaConnector","type":"object","required":["items"],"properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"items":{"description":"List of kafkaconnectors. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md","type":"array","items":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaConnector"}},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"}]}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaConnectorList","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaList":{"description":"KafkaList is a list of Kafka","type":"object","required":["items"],"properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"items":{"description":"List of kafkas. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md","type":"array","items":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.Kafka"}},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"}]}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaList","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaMirrorMaker":{"type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"}]},"spec":{"description":"The specification of Kafka MirrorMaker.","type":"object","required":["replicas","consumer","producer"],"oneOf":[{"required":["include"],"properties":{"include":{}}},{"required":["whitelist"],"properties":{"whitelist":{}}}],"properties":{"consumer":{"description":"Configuration of source cluster.","type":"object","required":["bootstrapServers","groupId"],"properties":{"authentication":{"description":"Authentication configuration for connecting to the cluster.","type":"object","required":["type"],"properties":{"accessToken":{"description":"Link to Kubernetes Secret containing the access token which was obtained from the authorization server.","type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}},"accessTokenIsJwt":{"description":"Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.","type":"boolean"},"audience":{"description":"OAuth audience to use when authenticating against the authorization server. Some authorization servers require the audience to be explicitly set. The possible values depend on how the authorization server is configured. By default, `audience` is not specified when performing the token endpoint request.","type":"string"},"certificateAndKey":{"description":"Reference to the `Secret` which holds the certificate and private key pair.","type":"object","required":["certificate","key","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"key":{"description":"The name of the private key in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}},"clientId":{"description":"OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.","type":"string"},"clientSecret":{"description":"Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.","type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}},"connectTimeoutSeconds":{"description":"The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.","type":"integer"},"disableTlsHostnameVerification":{"description":"Enable or disable TLS hostname verification. Default value is `false`.","type":"boolean"},"enableMetrics":{"description":"Enable or disable OAuth metrics. Default value is `false`.","type":"boolean"},"httpRetries":{"description":"The maximum number of retries to attempt if an initial HTTP request fails. If not set, the default is to not attempt any retries.","type":"integer"},"httpRetryPauseMs":{"description":"The pause to take before retrying a failed HTTP request. If not set, the default is to not pause at all but to immediately repeat a request.","type":"integer"},"maxTokenExpirySeconds":{"description":"Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.","type":"integer"},"passwordSecret":{"description":"Reference to the `Secret` which holds the password.","type":"object","required":["password","secretName"],"properties":{"password":{"description":"The name of the key in the Secret under which the password is stored.","type":"string"},"secretName":{"description":"The name of the Secret containing the password.","type":"string"}}},"readTimeoutSeconds":{"description":"The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.","type":"integer"},"refreshToken":{"description":"Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.","type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}},"scope":{"description":"OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.","type":"string"},"tlsTrustedCertificates":{"description":"Trusted certificates for TLS connection to the OAuth server.","type":"array","items":{"type":"object","required":["certificate","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}}},"tokenEndpointUri":{"description":"Authorization server token endpoint URI.","type":"string"},"type":{"description":"Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.","type":"string","enum":["tls","scram-sha-256","scram-sha-512","plain","oauth"]},"username":{"description":"Username used for the authentication.","type":"string"}}},"bootstrapServers":{"description":"A list of host:port pairs for establishing the initial connection to the Kafka cluster.","type":"string"},"config":{"description":"The MirrorMaker consumer config. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, group.id, sasl., security., interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).","type":"object","x-kubernetes-preserve-unknown-fields":true},"groupId":{"description":"A unique string that identifies the consumer group this consumer belongs to.","type":"string"},"numStreams":{"description":"Specifies the number of consumer stream threads to create.","type":"integer","minimum":1},"offsetCommitInterval":{"description":"Specifies the offset auto-commit interval in ms. Default value is 60000.","type":"integer"},"tls":{"description":"TLS configuration for connecting MirrorMaker to the cluster.","type":"object","properties":{"trustedCertificates":{"description":"Trusted certificates for TLS connection.","type":"array","items":{"type":"object","required":["certificate","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}}}}}}},"image":{"description":"The docker image for the pods.","type":"string"},"include":{"description":"List of topics which are included for mirroring. This option allows any regular expression using Java-style regular expressions. Mirroring two topics named A and B is achieved by using the expression `A\\|B`. Or, as a special case, you can mirror all topics using the regular expression `*`. You can also specify multiple regular expressions separated by commas.","type":"string"},"jvmOptions":{"description":"JVM Options for pods.","type":"object","properties":{"-XX":{"description":"A map of -XX options to the JVM.","type":"object","x-kubernetes-preserve-unknown-fields":true},"-Xms":{"description":"-Xms option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"-Xmx":{"description":"-Xmx option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"gcLoggingEnabled":{"description":"Specifies whether the Garbage Collection logging is enabled. The default is false.","type":"boolean"},"javaSystemProperties":{"description":"A map of additional system properties which will be passed using the `-D` option to the JVM.","type":"array","items":{"type":"object","properties":{"name":{"description":"The system property name.","type":"string"},"value":{"description":"The system property value.","type":"string"}}}}}},"livenessProbe":{"description":"Pod liveness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"logging":{"description":"Logging configuration for MirrorMaker.","type":"object","required":["type"],"properties":{"loggers":{"description":"A Map from logger name to logger level.","type":"object","x-kubernetes-preserve-unknown-fields":true},"type":{"description":"Logging type, must be either 'inline' or 'external'.","type":"string","enum":["inline","external"]},"valueFrom":{"description":"`ConfigMap` entry where the logging configuration is stored. ","type":"object","properties":{"configMapKeyRef":{"description":"Reference to the key in the ConfigMap containing the configuration.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}},"metricsConfig":{"description":"Metrics configuration.","type":"object","required":["type","valueFrom"],"properties":{"type":{"description":"Metrics type. Only 'jmxPrometheusExporter' supported currently.","type":"string","enum":["jmxPrometheusExporter"]},"valueFrom":{"description":"ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.","type":"object","properties":{"configMapKeyRef":{"description":"Reference to the key in the ConfigMap containing the configuration.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}},"producer":{"description":"Configuration of target cluster.","type":"object","required":["bootstrapServers"],"properties":{"abortOnSendFailure":{"description":"Flag to set the MirrorMaker to exit on a failed send. Default value is `true`.","type":"boolean"},"authentication":{"description":"Authentication configuration for connecting to the cluster.","type":"object","required":["type"],"properties":{"accessToken":{"description":"Link to Kubernetes Secret containing the access token which was obtained from the authorization server.","type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}},"accessTokenIsJwt":{"description":"Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.","type":"boolean"},"audience":{"description":"OAuth audience to use when authenticating against the authorization server. Some authorization servers require the audience to be explicitly set. The possible values depend on how the authorization server is configured. By default, `audience` is not specified when performing the token endpoint request.","type":"string"},"certificateAndKey":{"description":"Reference to the `Secret` which holds the certificate and private key pair.","type":"object","required":["certificate","key","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"key":{"description":"The name of the private key in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}},"clientId":{"description":"OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.","type":"string"},"clientSecret":{"description":"Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.","type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}},"connectTimeoutSeconds":{"description":"The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.","type":"integer"},"disableTlsHostnameVerification":{"description":"Enable or disable TLS hostname verification. Default value is `false`.","type":"boolean"},"enableMetrics":{"description":"Enable or disable OAuth metrics. Default value is `false`.","type":"boolean"},"httpRetries":{"description":"The maximum number of retries to attempt if an initial HTTP request fails. If not set, the default is to not attempt any retries.","type":"integer"},"httpRetryPauseMs":{"description":"The pause to take before retrying a failed HTTP request. If not set, the default is to not pause at all but to immediately repeat a request.","type":"integer"},"maxTokenExpirySeconds":{"description":"Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.","type":"integer"},"passwordSecret":{"description":"Reference to the `Secret` which holds the password.","type":"object","required":["password","secretName"],"properties":{"password":{"description":"The name of the key in the Secret under which the password is stored.","type":"string"},"secretName":{"description":"The name of the Secret containing the password.","type":"string"}}},"readTimeoutSeconds":{"description":"The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.","type":"integer"},"refreshToken":{"description":"Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.","type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}},"scope":{"description":"OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.","type":"string"},"tlsTrustedCertificates":{"description":"Trusted certificates for TLS connection to the OAuth server.","type":"array","items":{"type":"object","required":["certificate","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}}},"tokenEndpointUri":{"description":"Authorization server token endpoint URI.","type":"string"},"type":{"description":"Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.","type":"string","enum":["tls","scram-sha-256","scram-sha-512","plain","oauth"]},"username":{"description":"Username used for the authentication.","type":"string"}}},"bootstrapServers":{"description":"A list of host:port pairs for establishing the initial connection to the Kafka cluster.","type":"string"},"config":{"description":"The MirrorMaker producer config. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, sasl., security., interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).","type":"object","x-kubernetes-preserve-unknown-fields":true},"tls":{"description":"TLS configuration for connecting MirrorMaker to the cluster.","type":"object","properties":{"trustedCertificates":{"description":"Trusted certificates for TLS connection.","type":"array","items":{"type":"object","required":["certificate","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}}}}}}},"readinessProbe":{"description":"Pod readiness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"replicas":{"description":"The number of pods in the `Deployment`.","type":"integer","minimum":0},"resources":{"description":"CPU and memory resources to reserve.","type":"object","properties":{"claims":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"limits":{"type":"object","x-kubernetes-preserve-unknown-fields":true},"requests":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"template":{"description":"Template to specify how Kafka MirrorMaker resources, `Deployments` and `Pods`, are generated.","type":"object","properties":{"deployment":{"description":"Template for Kafka MirrorMaker `Deployment`.","type":"object","properties":{"deploymentStrategy":{"description":"Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.","type":"string","enum":["RollingUpdate","Recreate"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"mirrorMakerContainer":{"description":"Template for Kafka MirrorMaker container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"pod":{"description":"Template for Kafka MirrorMaker `Pods`.","type":"object","properties":{"affinity":{"description":"The pod's affinity rules.","type":"object","properties":{"nodeAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"preference":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"object","properties":{"nodeSelectorTerms":{"type":"array","items":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}}}}}}},"podAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}},"podAntiAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}}}},"enableServiceLinks":{"description":"Indicates whether information about services should be injected into Pod's environment variables.","type":"boolean"},"hostAliases":{"description":"The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.","type":"array","items":{"type":"object","properties":{"hostnames":{"type":"array","items":{"type":"string"}},"ip":{"type":"string"}}}},"imagePullSecrets":{"description":"List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.","type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"priorityClassName":{"description":"The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.","type":"string"},"schedulerName":{"description":"The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.","type":"string"},"securityContext":{"description":"Configures pod-level security attributes and common container settings.","type":"object","properties":{"fsGroup":{"type":"integer"},"fsGroupChangePolicy":{"type":"string"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"supplementalGroups":{"type":"array","items":{"type":"integer"}},"sysctls":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"value":{"type":"string"}}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}},"terminationGracePeriodSeconds":{"description":"The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.","type":"integer","minimum":0},"tmpDirSizeLimit":{"description":"Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"tolerations":{"description":"The pod's tolerations.","type":"array","items":{"type":"object","properties":{"effect":{"type":"string"},"key":{"type":"string"},"operator":{"type":"string"},"tolerationSeconds":{"type":"integer"},"value":{"type":"string"}}}},"topologySpreadConstraints":{"description":"The pod's topology spread constraints.","type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"matchLabelKeys":{"type":"array","items":{"type":"string"}},"maxSkew":{"type":"integer"},"minDomains":{"type":"integer"},"nodeAffinityPolicy":{"type":"string"},"nodeTaintsPolicy":{"type":"string"},"topologyKey":{"type":"string"},"whenUnsatisfiable":{"type":"string"}}}}}},"podDisruptionBudget":{"description":"Template for Kafka MirrorMaker `PodDisruptionBudget`.","type":"object","properties":{"maxUnavailable":{"description":"Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.","type":"integer","minimum":0},"metadata":{"description":"Metadata to apply to the `PodDisruptionBudgetTemplate` resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"serviceAccount":{"description":"Template for the Kafka MirrorMaker service account.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}}}},"tracing":{"description":"The configuration of tracing in Kafka MirrorMaker.","type":"object","required":["type"],"properties":{"type":{"description":"Type of the tracing used. Currently the only supported types are `jaeger` for OpenTracing (Jaeger) tracing and `opentelemetry` for OpenTelemetry tracing. The OpenTracing (Jaeger) tracing is deprecated.","type":"string","enum":["jaeger","opentelemetry"]}}},"version":{"description":"The Kafka MirrorMaker version. Defaults to {DefaultKafkaVersion}. Consult the documentation to understand the process required to upgrade or downgrade the version.","type":"string"},"whitelist":{"description":"List of topics which are included for mirroring. This option allows any regular expression using Java-style regular expressions. Mirroring two topics named A and B is achieved by using the expression `A\\|B`. Or, as a special case, you can mirror all topics using the regular expression `*`. You can also specify multiple regular expressions separated by commas.","type":"string"}}},"status":{"description":"The status of Kafka MirrorMaker.","type":"object","properties":{"conditions":{"description":"List of status conditions.","type":"array","items":{"type":"object","properties":{"lastTransitionTime":{"description":"Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.","type":"string"},"message":{"description":"Human-readable message indicating details about the condition's last transition.","type":"string"},"reason":{"description":"The reason for the condition's last transition (a single word in CamelCase).","type":"string"},"status":{"description":"The status of the condition, either True, False or Unknown.","type":"string"},"type":{"description":"The unique identifier of a condition, used to distinguish between other conditions in the resource.","type":"string"}}}},"labelSelector":{"description":"Label selector for pods providing this resource.","type":"string"},"observedGeneration":{"description":"The generation of the CRD that was last reconciled by the operator.","type":"integer"},"replicas":{"description":"The current number of pods being used to provide this resource.","type":"integer"}}}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaMirrorMaker","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaMirrorMaker2":{"type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"}]},"spec":{"description":"The specification of the Kafka MirrorMaker 2 cluster.","type":"object","required":["connectCluster"],"properties":{"clientRackInitImage":{"description":"The image of the init container used for initializing the `client.rack`.","type":"string"},"clusters":{"description":"Kafka clusters for mirroring.","type":"array","items":{"type":"object","required":["alias","bootstrapServers"],"properties":{"alias":{"description":"Alias used to reference the Kafka cluster.","type":"string","pattern":"^[a-zA-Z0-9\\._\\-]{1,100}$"},"authentication":{"description":"Authentication configuration for connecting to the cluster.","type":"object","required":["type"],"properties":{"accessToken":{"description":"Link to Kubernetes Secret containing the access token which was obtained from the authorization server.","type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}},"accessTokenIsJwt":{"description":"Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.","type":"boolean"},"audience":{"description":"OAuth audience to use when authenticating against the authorization server. Some authorization servers require the audience to be explicitly set. The possible values depend on how the authorization server is configured. By default, `audience` is not specified when performing the token endpoint request.","type":"string"},"certificateAndKey":{"description":"Reference to the `Secret` which holds the certificate and private key pair.","type":"object","required":["certificate","key","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"key":{"description":"The name of the private key in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}},"clientId":{"description":"OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.","type":"string"},"clientSecret":{"description":"Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.","type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}},"connectTimeoutSeconds":{"description":"The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.","type":"integer"},"disableTlsHostnameVerification":{"description":"Enable or disable TLS hostname verification. Default value is `false`.","type":"boolean"},"enableMetrics":{"description":"Enable or disable OAuth metrics. Default value is `false`.","type":"boolean"},"httpRetries":{"description":"The maximum number of retries to attempt if an initial HTTP request fails. If not set, the default is to not attempt any retries.","type":"integer"},"httpRetryPauseMs":{"description":"The pause to take before retrying a failed HTTP request. If not set, the default is to not pause at all but to immediately repeat a request.","type":"integer"},"maxTokenExpirySeconds":{"description":"Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.","type":"integer"},"passwordSecret":{"description":"Reference to the `Secret` which holds the password.","type":"object","required":["password","secretName"],"properties":{"password":{"description":"The name of the key in the Secret under which the password is stored.","type":"string"},"secretName":{"description":"The name of the Secret containing the password.","type":"string"}}},"readTimeoutSeconds":{"description":"The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.","type":"integer"},"refreshToken":{"description":"Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.","type":"object","required":["key","secretName"],"properties":{"key":{"description":"The key under which the secret value is stored in the Kubernetes Secret.","type":"string"},"secretName":{"description":"The name of the Kubernetes Secret containing the secret value.","type":"string"}}},"scope":{"description":"OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.","type":"string"},"tlsTrustedCertificates":{"description":"Trusted certificates for TLS connection to the OAuth server.","type":"array","items":{"type":"object","required":["certificate","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}}},"tokenEndpointUri":{"description":"Authorization server token endpoint URI.","type":"string"},"type":{"description":"Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.","type":"string","enum":["tls","scram-sha-256","scram-sha-512","plain","oauth"]},"username":{"description":"Username used for the authentication.","type":"string"}}},"bootstrapServers":{"description":"A comma-separated list of `host:port` pairs for establishing the connection to the Kafka cluster.","type":"string"},"config":{"description":"The MirrorMaker 2 cluster config. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).","type":"object","x-kubernetes-preserve-unknown-fields":true},"tls":{"description":"TLS configuration for connecting MirrorMaker 2 connectors to a cluster.","type":"object","properties":{"trustedCertificates":{"description":"Trusted certificates for TLS connection.","type":"array","items":{"type":"object","required":["certificate","secretName"],"properties":{"certificate":{"description":"The name of the file certificate in the Secret.","type":"string"},"secretName":{"description":"The name of the Secret containing the certificate.","type":"string"}}}}}}}}},"connectCluster":{"description":"The cluster alias used for Kafka Connect. The alias must match a cluster in the list at `spec.clusters`.","type":"string"},"externalConfiguration":{"description":"Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.","type":"object","properties":{"env":{"description":"Makes data from a Secret or ConfigMap available in the Kafka Connect pods as environment variables.","type":"array","items":{"type":"object","required":["name","valueFrom"],"properties":{"name":{"description":"Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.","type":"string"},"valueFrom":{"description":"Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.","type":"object","properties":{"configMapKeyRef":{"description":"Reference to a key in a ConfigMap.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}},"secretKeyRef":{"description":"Reference to a key in a Secret.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}}},"volumes":{"description":"Makes data from a Secret or ConfigMap available in the Kafka Connect pods as volumes.","type":"array","items":{"type":"object","required":["name"],"properties":{"configMap":{"description":"Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.","type":"object","properties":{"defaultMode":{"type":"integer"},"items":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"mode":{"type":"integer"},"path":{"type":"string"}}}},"name":{"type":"string"},"optional":{"type":"boolean"}}},"name":{"description":"Name of the volume which will be added to the Kafka Connect pods.","type":"string"},"secret":{"description":"Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.","type":"object","properties":{"defaultMode":{"type":"integer"},"items":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"mode":{"type":"integer"},"path":{"type":"string"}}}},"optional":{"type":"boolean"},"secretName":{"type":"string"}}}}}}}},"image":{"description":"The docker image for the pods.","type":"string"},"jmxOptions":{"description":"JMX Options.","type":"object","properties":{"authentication":{"description":"Authentication configuration for connecting to the JMX port.","type":"object","required":["type"],"properties":{"type":{"description":"Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.","type":"string","enum":["password"]}}}}},"jvmOptions":{"description":"JVM Options for pods.","type":"object","properties":{"-XX":{"description":"A map of -XX options to the JVM.","type":"object","x-kubernetes-preserve-unknown-fields":true},"-Xms":{"description":"-Xms option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"-Xmx":{"description":"-Xmx option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"gcLoggingEnabled":{"description":"Specifies whether the Garbage Collection logging is enabled. The default is false.","type":"boolean"},"javaSystemProperties":{"description":"A map of additional system properties which will be passed using the `-D` option to the JVM.","type":"array","items":{"type":"object","properties":{"name":{"description":"The system property name.","type":"string"},"value":{"description":"The system property value.","type":"string"}}}}}},"livenessProbe":{"description":"Pod liveness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"logging":{"description":"Logging configuration for Kafka Connect.","type":"object","required":["type"],"properties":{"loggers":{"description":"A Map from logger name to logger level.","type":"object","x-kubernetes-preserve-unknown-fields":true},"type":{"description":"Logging type, must be either 'inline' or 'external'.","type":"string","enum":["inline","external"]},"valueFrom":{"description":"`ConfigMap` entry where the logging configuration is stored. ","type":"object","properties":{"configMapKeyRef":{"description":"Reference to the key in the ConfigMap containing the configuration.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}},"metricsConfig":{"description":"Metrics configuration.","type":"object","required":["type","valueFrom"],"properties":{"type":{"description":"Metrics type. Only 'jmxPrometheusExporter' supported currently.","type":"string","enum":["jmxPrometheusExporter"]},"valueFrom":{"description":"ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.","type":"object","properties":{"configMapKeyRef":{"description":"Reference to the key in the ConfigMap containing the configuration.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}},"mirrors":{"description":"Configuration of the MirrorMaker 2 connectors.","type":"array","items":{"type":"object","required":["sourceCluster","targetCluster"],"properties":{"checkpointConnector":{"description":"The specification of the Kafka MirrorMaker 2 checkpoint connector.","type":"object","properties":{"autoRestart":{"description":"Automatic restart of connector and tasks configuration.","type":"object","properties":{"enabled":{"description":"Whether automatic restart for failed connectors and tasks should be enabled or disabled.","type":"boolean"}}},"config":{"description":"The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.","type":"object","x-kubernetes-preserve-unknown-fields":true},"pause":{"description":"Whether the connector should be paused. Defaults to false.","type":"boolean"},"tasksMax":{"description":"The maximum number of tasks for the Kafka Connector.","type":"integer","minimum":1}}},"groupsBlacklistPattern":{"description":"A regular expression matching the consumer groups to exclude from mirroring. Comma-separated lists are also supported.","type":"string"},"groupsExcludePattern":{"description":"A regular expression matching the consumer groups to exclude from mirroring. Comma-separated lists are also supported.","type":"string"},"groupsPattern":{"description":"A regular expression matching the consumer groups to be mirrored. Comma-separated lists are also supported.","type":"string"},"heartbeatConnector":{"description":"The specification of the Kafka MirrorMaker 2 heartbeat connector.","type":"object","properties":{"autoRestart":{"description":"Automatic restart of connector and tasks configuration.","type":"object","properties":{"enabled":{"description":"Whether automatic restart for failed connectors and tasks should be enabled or disabled.","type":"boolean"}}},"config":{"description":"The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.","type":"object","x-kubernetes-preserve-unknown-fields":true},"pause":{"description":"Whether the connector should be paused. Defaults to false.","type":"boolean"},"tasksMax":{"description":"The maximum number of tasks for the Kafka Connector.","type":"integer","minimum":1}}},"sourceCluster":{"description":"The alias of the source cluster used by the Kafka MirrorMaker 2 connectors. The alias must match a cluster in the list at `spec.clusters`.","type":"string"},"sourceConnector":{"description":"The specification of the Kafka MirrorMaker 2 source connector.","type":"object","properties":{"autoRestart":{"description":"Automatic restart of connector and tasks configuration.","type":"object","properties":{"enabled":{"description":"Whether automatic restart for failed connectors and tasks should be enabled or disabled.","type":"boolean"}}},"config":{"description":"The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.","type":"object","x-kubernetes-preserve-unknown-fields":true},"pause":{"description":"Whether the connector should be paused. Defaults to false.","type":"boolean"},"tasksMax":{"description":"The maximum number of tasks for the Kafka Connector.","type":"integer","minimum":1}}},"targetCluster":{"description":"The alias of the target cluster used by the Kafka MirrorMaker 2 connectors. The alias must match a cluster in the list at `spec.clusters`.","type":"string"},"topicsBlacklistPattern":{"description":"A regular expression matching the topics to exclude from mirroring. Comma-separated lists are also supported.","type":"string"},"topicsExcludePattern":{"description":"A regular expression matching the topics to exclude from mirroring. Comma-separated lists are also supported.","type":"string"},"topicsPattern":{"description":"A regular expression matching the topics to be mirrored, for example, \"topic1\\|topic2\\|topic3\". Comma-separated lists are also supported.","type":"string"}}}},"rack":{"description":"Configuration of the node label which will be used as the `client.rack` consumer configuration.","type":"object","required":["topologyKey"],"properties":{"topologyKey":{"description":"A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set a broker's `broker.rack` config, and the `client.rack` config for Kafka Connect or MirrorMaker 2.","type":"string"}}},"readinessProbe":{"description":"Pod readiness checking.","type":"object","properties":{"failureThreshold":{"description":"Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.","type":"integer","minimum":1},"initialDelaySeconds":{"description":"The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.","type":"integer","minimum":0},"periodSeconds":{"description":"How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.","type":"integer","minimum":1},"successThreshold":{"description":"Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.","type":"integer","minimum":1},"timeoutSeconds":{"description":"The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.","type":"integer","minimum":1}}},"replicas":{"description":"The number of pods in the Kafka Connect group. Defaults to `3`.","type":"integer"},"resources":{"description":"The maximum limits for CPU and memory resources and the requested initial resources.","type":"object","properties":{"claims":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"limits":{"type":"object","x-kubernetes-preserve-unknown-fields":true},"requests":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"template":{"description":"Template for Kafka Connect and Kafka Mirror Maker 2 resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.","type":"object","properties":{"apiService":{"description":"Template for Kafka Connect API `Service`.","type":"object","properties":{"ipFamilies":{"description":"Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.","type":"array","items":{"type":"string","enum":["IPv4","IPv6"]}},"ipFamilyPolicy":{"description":"Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.","type":"string","enum":["SingleStack","PreferDualStack","RequireDualStack"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"buildConfig":{"description":"Template for the Kafka Connect BuildConfig used to build new container images. The BuildConfig is used only on OpenShift.","type":"object","properties":{"metadata":{"description":"Metadata to apply to the `PodDisruptionBudgetTemplate` resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"pullSecret":{"description":"Container Registry Secret with the credentials for pulling the base image.","type":"string"}}},"buildContainer":{"description":"Template for the Kafka Connect Build container. The build container is used only on Kubernetes.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"buildPod":{"description":"Template for Kafka Connect Build `Pods`. The build pod is used only on Kubernetes.","type":"object","properties":{"affinity":{"description":"The pod's affinity rules.","type":"object","properties":{"nodeAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"preference":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"object","properties":{"nodeSelectorTerms":{"type":"array","items":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}}}}}}},"podAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}},"podAntiAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}}}},"enableServiceLinks":{"description":"Indicates whether information about services should be injected into Pod's environment variables.","type":"boolean"},"hostAliases":{"description":"The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.","type":"array","items":{"type":"object","properties":{"hostnames":{"type":"array","items":{"type":"string"}},"ip":{"type":"string"}}}},"imagePullSecrets":{"description":"List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.","type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"priorityClassName":{"description":"The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.","type":"string"},"schedulerName":{"description":"The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.","type":"string"},"securityContext":{"description":"Configures pod-level security attributes and common container settings.","type":"object","properties":{"fsGroup":{"type":"integer"},"fsGroupChangePolicy":{"type":"string"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"supplementalGroups":{"type":"array","items":{"type":"integer"}},"sysctls":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"value":{"type":"string"}}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}},"terminationGracePeriodSeconds":{"description":"The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.","type":"integer","minimum":0},"tmpDirSizeLimit":{"description":"Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"tolerations":{"description":"The pod's tolerations.","type":"array","items":{"type":"object","properties":{"effect":{"type":"string"},"key":{"type":"string"},"operator":{"type":"string"},"tolerationSeconds":{"type":"integer"},"value":{"type":"string"}}}},"topologySpreadConstraints":{"description":"The pod's topology spread constraints.","type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"matchLabelKeys":{"type":"array","items":{"type":"string"}},"maxSkew":{"type":"integer"},"minDomains":{"type":"integer"},"nodeAffinityPolicy":{"type":"string"},"nodeTaintsPolicy":{"type":"string"},"topologyKey":{"type":"string"},"whenUnsatisfiable":{"type":"string"}}}}}},"buildServiceAccount":{"description":"Template for the Kafka Connect Build service account.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"clusterRoleBinding":{"description":"Template for the Kafka Connect ClusterRoleBinding.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"connectContainer":{"description":"Template for the Kafka Connect container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"deployment":{"description":"Template for Kafka Connect `Deployment`.","type":"object","properties":{"deploymentStrategy":{"description":"Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.","type":"string","enum":["RollingUpdate","Recreate"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"headlessService":{"description":"Template for Kafka Connect headless `Service`.","type":"object","properties":{"ipFamilies":{"description":"Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.","type":"array","items":{"type":"string","enum":["IPv4","IPv6"]}},"ipFamilyPolicy":{"description":"Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.","type":"string","enum":["SingleStack","PreferDualStack","RequireDualStack"]},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"initContainer":{"description":"Template for the Kafka init container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"jmxSecret":{"description":"Template for Secret of the Kafka Connect Cluster JMX authentication.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"pod":{"description":"Template for Kafka Connect `Pods`.","type":"object","properties":{"affinity":{"description":"The pod's affinity rules.","type":"object","properties":{"nodeAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"preference":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"object","properties":{"nodeSelectorTerms":{"type":"array","items":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}}}}}}},"podAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}},"podAntiAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}}}},"enableServiceLinks":{"description":"Indicates whether information about services should be injected into Pod's environment variables.","type":"boolean"},"hostAliases":{"description":"The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.","type":"array","items":{"type":"object","properties":{"hostnames":{"type":"array","items":{"type":"string"}},"ip":{"type":"string"}}}},"imagePullSecrets":{"description":"List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.","type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"priorityClassName":{"description":"The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.","type":"string"},"schedulerName":{"description":"The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.","type":"string"},"securityContext":{"description":"Configures pod-level security attributes and common container settings.","type":"object","properties":{"fsGroup":{"type":"integer"},"fsGroupChangePolicy":{"type":"string"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"supplementalGroups":{"type":"array","items":{"type":"integer"}},"sysctls":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"value":{"type":"string"}}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}},"terminationGracePeriodSeconds":{"description":"The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.","type":"integer","minimum":0},"tmpDirSizeLimit":{"description":"Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"tolerations":{"description":"The pod's tolerations.","type":"array","items":{"type":"object","properties":{"effect":{"type":"string"},"key":{"type":"string"},"operator":{"type":"string"},"tolerationSeconds":{"type":"integer"},"value":{"type":"string"}}}},"topologySpreadConstraints":{"description":"The pod's topology spread constraints.","type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"matchLabelKeys":{"type":"array","items":{"type":"string"}},"maxSkew":{"type":"integer"},"minDomains":{"type":"integer"},"nodeAffinityPolicy":{"type":"string"},"nodeTaintsPolicy":{"type":"string"},"topologyKey":{"type":"string"},"whenUnsatisfiable":{"type":"string"}}}}}},"podDisruptionBudget":{"description":"Template for Kafka Connect `PodDisruptionBudget`.","type":"object","properties":{"maxUnavailable":{"description":"Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.","type":"integer","minimum":0},"metadata":{"description":"Metadata to apply to the `PodDisruptionBudgetTemplate` resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"podSet":{"description":"Template for Kafka Connect `StrimziPodSet` resource.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"serviceAccount":{"description":"Template for the Kafka Connect service account.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}}}},"tracing":{"description":"The configuration of tracing in Kafka Connect.","type":"object","required":["type"],"properties":{"type":{"description":"Type of the tracing used. Currently the only supported types are `jaeger` for OpenTracing (Jaeger) tracing and `opentelemetry` for OpenTelemetry tracing. The OpenTracing (Jaeger) tracing is deprecated.","type":"string","enum":["jaeger","opentelemetry"]}}},"version":{"description":"The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.","type":"string"}}},"status":{"description":"The status of the Kafka MirrorMaker 2 cluster.","type":"object","properties":{"autoRestartStatuses":{"description":"List of MirrorMaker 2 connector auto restart statuses.","type":"array","items":{"type":"object","properties":{"connectorName":{"description":"The name of the connector being restarted.","type":"string"},"count":{"description":"The number of times the connector or task is restarted.","type":"integer"},"lastRestartTimestamp":{"description":"The last time the automatic restart was attempted. The required format is 'yyyy-MM-ddTHH:mm:ssZ' in the UTC time zone.","type":"string"}}}},"conditions":{"description":"List of status conditions.","type":"array","items":{"type":"object","properties":{"lastTransitionTime":{"description":"Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.","type":"string"},"message":{"description":"Human-readable message indicating details about the condition's last transition.","type":"string"},"reason":{"description":"The reason for the condition's last transition (a single word in CamelCase).","type":"string"},"status":{"description":"The status of the condition, either True, False or Unknown.","type":"string"},"type":{"description":"The unique identifier of a condition, used to distinguish between other conditions in the resource.","type":"string"}}}},"connectorPlugins":{"description":"The list of connector plugins available in this Kafka Connect deployment.","type":"array","items":{"type":"object","properties":{"class":{"description":"The class of the connector plugin.","type":"string"},"type":{"description":"The type of the connector plugin. The available types are `sink` and `source`.","type":"string"},"version":{"description":"The version of the connector plugin.","type":"string"}}}},"connectors":{"description":"List of MirrorMaker 2 connector statuses, as reported by the Kafka Connect REST API.","type":"array","items":{"type":"object","x-kubernetes-preserve-unknown-fields":true}},"labelSelector":{"description":"Label selector for pods providing this resource.","type":"string"},"observedGeneration":{"description":"The generation of the CRD that was last reconciled by the operator.","type":"integer"},"replicas":{"description":"The current number of pods being used to provide this resource.","type":"integer"},"url":{"description":"The URL of the REST API endpoint for managing and monitoring Kafka Connect connectors.","type":"string"}}}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaMirrorMaker2","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaMirrorMaker2List":{"description":"KafkaMirrorMaker2List is a list of KafkaMirrorMaker2","type":"object","required":["items"],"properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"items":{"description":"List of kafkamirrormaker2s. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md","type":"array","items":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker2"}},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"}]}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaMirrorMaker2List","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaMirrorMakerList":{"description":"KafkaMirrorMakerList is a list of KafkaMirrorMaker","type":"object","required":["items"],"properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"items":{"description":"List of kafkamirrormakers. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md","type":"array","items":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaMirrorMaker"}},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"}]}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaMirrorMakerList","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaNodePool":{"type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"}]},"spec":{"description":"The specification of the KafkaNodePool.","type":"object","required":["replicas","storage","roles"],"properties":{"jvmOptions":{"description":"JVM Options for pods.","type":"object","properties":{"-XX":{"description":"A map of -XX options to the JVM.","type":"object","x-kubernetes-preserve-unknown-fields":true},"-Xms":{"description":"-Xms option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"-Xmx":{"description":"-Xmx option to to the JVM.","type":"string","pattern":"^[0-9]+[mMgG]?$"},"gcLoggingEnabled":{"description":"Specifies whether the Garbage Collection logging is enabled. The default is false.","type":"boolean"},"javaSystemProperties":{"description":"A map of additional system properties which will be passed using the `-D` option to the JVM.","type":"array","items":{"type":"object","properties":{"name":{"description":"The system property name.","type":"string"},"value":{"description":"The system property value.","type":"string"}}}}}},"replicas":{"description":"The number of pods in the pool.","type":"integer","minimum":0},"resources":{"description":"CPU and memory resources to reserve.","type":"object","properties":{"claims":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"limits":{"type":"object","x-kubernetes-preserve-unknown-fields":true},"requests":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"roles":{"description":"The roles that the nodes in this pool will have when KRaft mode is enabled. Supported values are 'broker' and 'controller'. This field is required. When KRaft mode is disabled, the only allowed value if `broker`.","type":"array","items":{"type":"string","enum":["controller","broker"]}},"storage":{"description":"Storage configuration (disk). Cannot be updated.","type":"object","required":["type"],"properties":{"class":{"description":"The storage class to use for dynamic volume allocation.","type":"string"},"deleteClaim":{"description":"Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.","type":"boolean"},"id":{"description":"Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.","type":"integer","minimum":0},"overrides":{"description":"Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.","type":"array","items":{"type":"object","properties":{"broker":{"description":"Id of the kafka broker (broker identifier).","type":"integer"},"class":{"description":"The storage class to use for dynamic volume allocation for this broker.","type":"string"}}}},"selector":{"description":"Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.","type":"object","x-kubernetes-preserve-unknown-fields":true},"size":{"description":"When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.","type":"string"},"sizeLimit":{"description":"When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"type":{"description":"Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.","type":"string","enum":["ephemeral","persistent-claim","jbod"]},"volumes":{"description":"List of volumes as Storage objects representing the JBOD disks array.","type":"array","items":{"type":"object","required":["type"],"properties":{"class":{"description":"The storage class to use for dynamic volume allocation.","type":"string"},"deleteClaim":{"description":"Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.","type":"boolean"},"id":{"description":"Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.","type":"integer","minimum":0},"overrides":{"description":"Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.","type":"array","items":{"type":"object","properties":{"broker":{"description":"Id of the kafka broker (broker identifier).","type":"integer"},"class":{"description":"The storage class to use for dynamic volume allocation for this broker.","type":"string"}}}},"selector":{"description":"Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.","type":"object","x-kubernetes-preserve-unknown-fields":true},"size":{"description":"When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.","type":"string"},"sizeLimit":{"description":"When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"type":{"description":"Storage type, must be either 'ephemeral' or 'persistent-claim'.","type":"string","enum":["ephemeral","persistent-claim"]}}}}}},"template":{"description":"Template for pool resources. The template allows users to specify how the resources belonging to this pool are generated.","type":"object","properties":{"initContainer":{"description":"Template for the Kafka init container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"kafkaContainer":{"description":"Template for the Kafka broker container.","type":"object","properties":{"env":{"description":"Environment variables which should be applied to the container.","type":"array","items":{"type":"object","properties":{"name":{"description":"The environment variable key.","type":"string"},"value":{"description":"The environment variable value.","type":"string"}}}},"securityContext":{"description":"Security context for the container.","type":"object","properties":{"allowPrivilegeEscalation":{"type":"boolean"},"capabilities":{"type":"object","properties":{"add":{"type":"array","items":{"type":"string"}},"drop":{"type":"array","items":{"type":"string"}}}},"privileged":{"type":"boolean"},"procMount":{"type":"string"},"readOnlyRootFilesystem":{"type":"boolean"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}}}},"perPodIngress":{"description":"Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"perPodRoute":{"description":"Template for Kafka per-pod `Routes` used for access from outside of OpenShift.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"perPodService":{"description":"Template for Kafka per-pod `Services` used for access from outside of Kubernetes.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"persistentVolumeClaim":{"description":"Template for all Kafka `PersistentVolumeClaims`.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}},"pod":{"description":"Template for Kafka `Pods`.","type":"object","properties":{"affinity":{"description":"The pod's affinity rules.","type":"object","properties":{"nodeAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"preference":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"object","properties":{"nodeSelectorTerms":{"type":"array","items":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchFields":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}}}}}}}}},"podAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}},"podAntiAffinity":{"type":"object","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"podAffinityTerm":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}},"weight":{"type":"integer"}}}},"requiredDuringSchedulingIgnoredDuringExecution":{"type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaceSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"namespaces":{"type":"array","items":{"type":"string"}},"topologyKey":{"type":"string"}}}}}}}},"enableServiceLinks":{"description":"Indicates whether information about services should be injected into Pod's environment variables.","type":"boolean"},"hostAliases":{"description":"The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.","type":"array","items":{"type":"object","properties":{"hostnames":{"type":"array","items":{"type":"string"}},"ip":{"type":"string"}}}},"imagePullSecrets":{"description":"List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.","type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}},"priorityClassName":{"description":"The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.","type":"string"},"schedulerName":{"description":"The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.","type":"string"},"securityContext":{"description":"Configures pod-level security attributes and common container settings.","type":"object","properties":{"fsGroup":{"type":"integer"},"fsGroupChangePolicy":{"type":"string"},"runAsGroup":{"type":"integer"},"runAsNonRoot":{"type":"boolean"},"runAsUser":{"type":"integer"},"seLinuxOptions":{"type":"object","properties":{"level":{"type":"string"},"role":{"type":"string"},"type":{"type":"string"},"user":{"type":"string"}}},"seccompProfile":{"type":"object","properties":{"localhostProfile":{"type":"string"},"type":{"type":"string"}}},"supplementalGroups":{"type":"array","items":{"type":"integer"}},"sysctls":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"value":{"type":"string"}}}},"windowsOptions":{"type":"object","properties":{"gmsaCredentialSpec":{"type":"string"},"gmsaCredentialSpecName":{"type":"string"},"hostProcess":{"type":"boolean"},"runAsUserName":{"type":"string"}}}}},"terminationGracePeriodSeconds":{"description":"The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.","type":"integer","minimum":0},"tmpDirSizeLimit":{"description":"Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.","type":"string","pattern":"^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"},"tolerations":{"description":"The pod's tolerations.","type":"array","items":{"type":"object","properties":{"effect":{"type":"string"},"key":{"type":"string"},"operator":{"type":"string"},"tolerationSeconds":{"type":"integer"},"value":{"type":"string"}}}},"topologySpreadConstraints":{"description":"The pod's topology spread constraints.","type":"array","items":{"type":"object","properties":{"labelSelector":{"type":"object","properties":{"matchExpressions":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"operator":{"type":"string"},"values":{"type":"array","items":{"type":"string"}}}}},"matchLabels":{"type":"object","x-kubernetes-preserve-unknown-fields":true}}},"matchLabelKeys":{"type":"array","items":{"type":"string"}},"maxSkew":{"type":"integer"},"minDomains":{"type":"integer"},"nodeAffinityPolicy":{"type":"string"},"nodeTaintsPolicy":{"type":"string"},"topologyKey":{"type":"string"},"whenUnsatisfiable":{"type":"string"}}}}}},"podSet":{"description":"Template for Kafka `StrimziPodSet` resource.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}}}}}},"status":{"description":"The status of the KafkaNodePool.","type":"object","properties":{"clusterId":{"description":"Kafka cluster ID.","type":"string"},"conditions":{"description":"List of status conditions.","type":"array","items":{"type":"object","properties":{"lastTransitionTime":{"description":"Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.","type":"string"},"message":{"description":"Human-readable message indicating details about the condition's last transition.","type":"string"},"reason":{"description":"The reason for the condition's last transition (a single word in CamelCase).","type":"string"},"status":{"description":"The status of the condition, either True, False or Unknown.","type":"string"},"type":{"description":"The unique identifier of a condition, used to distinguish between other conditions in the resource.","type":"string"}}}},"labelSelector":{"description":"Label selector for pods providing this resource.","type":"string"},"nodeIds":{"description":"Node IDs used by Kafka nodes in this pool.","type":"array","items":{"type":"integer"}},"observedGeneration":{"description":"The generation of the CRD that was last reconciled by the operator.","type":"integer"},"replicas":{"description":"The current number of pods being used to provide this resource.","type":"integer"}}}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaNodePool","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaNodePoolList":{"description":"KafkaNodePoolList is a list of KafkaNodePool","type":"object","required":["items"],"properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"items":{"description":"List of kafkanodepools. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md","type":"array","items":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaNodePool"}},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"}]}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaNodePoolList","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaRebalance":{"type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"}]},"spec":{"description":"The specification of the Kafka rebalance.","type":"object","properties":{"brokers":{"description":"The list of newly added brokers in case of scaling up or the ones to be removed in case of scaling down to use for rebalancing. This list can be used only with rebalancing mode `add-brokers` and `removed-brokers`. It is ignored with `full` mode.","type":"array","items":{"type":"integer"}},"concurrentIntraBrokerPartitionMovements":{"description":"The upper bound of ongoing partition replica movements between disks within each broker. Default is 2.","type":"integer","minimum":0},"concurrentLeaderMovements":{"description":"The upper bound of ongoing partition leadership movements. Default is 1000.","type":"integer","minimum":0},"concurrentPartitionMovementsPerBroker":{"description":"The upper bound of ongoing partition replica movements going into/out of each broker. Default is 5.","type":"integer","minimum":0},"excludedTopics":{"description":"A regular expression where any matching topics will be excluded from the calculation of optimization proposals. This expression will be parsed by the java.util.regex.Pattern class; for more information on the supported format consult the documentation for that class.","type":"string"},"goals":{"description":"A list of goals, ordered by decreasing priority, to use for generating and executing the rebalance proposal. The supported goals are available at https://github.com/linkedin/cruise-control#goals. If an empty goals list is provided, the goals declared in the default.goals Cruise Control configuration parameter are used.","type":"array","items":{"type":"string"}},"mode":{"description":"Mode to run the rebalancing. The supported modes are `full`, `add-brokers`, `remove-brokers`.\nIf not specified, the `full` mode is used by default. \n\n* `full` mode runs the rebalancing across all the brokers in the cluster.\n* `add-brokers` mode can be used after scaling up the cluster to move some replicas to the newly added brokers.\n* `remove-brokers` mode can be used before scaling down the cluster to move replicas out of the brokers to be removed.\n","type":"string","enum":["full","add-brokers","remove-brokers"]},"rebalanceDisk":{"description":"Enables intra-broker disk balancing, which balances disk space utilization between disks on the same broker. Only applies to Kafka deployments that use JBOD storage with multiple disks. When enabled, inter-broker balancing is disabled. Default is false.","type":"boolean"},"replicaMovementStrategies":{"description":"A list of strategy class names used to determine the execution order for the replica movements in the generated optimization proposal. By default BaseReplicaMovementStrategy is used, which will execute the replica movements in the order that they were generated.","type":"array","items":{"type":"string"}},"replicationThrottle":{"description":"The upper bound, in bytes per second, on the bandwidth used to move replicas. There is no limit by default.","type":"integer","minimum":0},"skipHardGoalCheck":{"description":"Whether to allow the hard goals specified in the Kafka CR to be skipped in optimization proposal generation. This can be useful when some of those hard goals are preventing a balance solution being found. Default is false.","type":"boolean"}}},"status":{"description":"The status of the Kafka rebalance.","type":"object","properties":{"conditions":{"description":"List of status conditions.","type":"array","items":{"type":"object","properties":{"lastTransitionTime":{"description":"Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.","type":"string"},"message":{"description":"Human-readable message indicating details about the condition's last transition.","type":"string"},"reason":{"description":"The reason for the condition's last transition (a single word in CamelCase).","type":"string"},"status":{"description":"The status of the condition, either True, False or Unknown.","type":"string"},"type":{"description":"The unique identifier of a condition, used to distinguish between other conditions in the resource.","type":"string"}}}},"observedGeneration":{"description":"The generation of the CRD that was last reconciled by the operator.","type":"integer"},"optimizationResult":{"description":"A JSON object describing the optimization result.","type":"object","x-kubernetes-preserve-unknown-fields":true},"sessionId":{"description":"The session identifier for requests to Cruise Control pertaining to this KafkaRebalance resource. This is used by the Kafka Rebalance operator to track the status of ongoing rebalancing operations.","type":"string"}}}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaRebalance","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaRebalanceList":{"description":"KafkaRebalanceList is a list of KafkaRebalance","type":"object","required":["items"],"properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"items":{"description":"List of kafkarebalances. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md","type":"array","items":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaRebalance"}},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"}]}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaRebalanceList","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaTopic":{"type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"}]},"spec":{"description":"The specification of the topic.","type":"object","properties":{"config":{"description":"The topic configuration.","type":"object","x-kubernetes-preserve-unknown-fields":true},"partitions":{"description":"The number of partitions the topic should have. This cannot be decreased after topic creation. It can be increased after topic creation, but it is important to understand the consequences that has, especially for topics with semantic partitioning. When absent this will default to the broker configuration for `num.partitions`.","type":"integer","minimum":1},"replicas":{"description":"The number of replicas the topic should have. When absent this will default to the broker configuration for `default.replication.factor`.","type":"integer","maximum":32767,"minimum":1},"topicName":{"description":"The name of the topic. When absent this will default to the metadata.name of the topic. It is recommended to not set this unless the topic name is not a valid Kubernetes resource name.","type":"string"}}},"status":{"description":"The status of the topic.","type":"object","properties":{"conditions":{"description":"List of status conditions.","type":"array","items":{"type":"object","properties":{"lastTransitionTime":{"description":"Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.","type":"string"},"message":{"description":"Human-readable message indicating details about the condition's last transition.","type":"string"},"reason":{"description":"The reason for the condition's last transition (a single word in CamelCase).","type":"string"},"status":{"description":"The status of the condition, either True, False or Unknown.","type":"string"},"type":{"description":"The unique identifier of a condition, used to distinguish between other conditions in the resource.","type":"string"}}}},"observedGeneration":{"description":"The generation of the CRD that was last reconciled by the operator.","type":"integer"},"topicName":{"description":"Topic name.","type":"string"}}}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaTopic","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaTopicList":{"description":"KafkaTopicList is a list of KafkaTopic","type":"object","required":["items"],"properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"items":{"description":"List of kafkatopics. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md","type":"array","items":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaTopic"}},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"}]}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaTopicList","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaUser":{"type":"object","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"}]},"spec":{"description":"The specification of the user.","type":"object","properties":{"authentication":{"description":"Authentication mechanism enabled for this Kafka user. The supported authentication mechanisms are `scram-sha-512`, `tls`, and `tls-external`. \n\n* `scram-sha-512` generates a secret with SASL SCRAM-SHA-512 credentials.\n* `tls` generates a secret with user certificate for mutual TLS authentication.\n* `tls-external` does not generate a user certificate.   But prepares the user for using mutual TLS authentication using a user certificate generated outside the User Operator.\n  ACLs and quotas set for this user are configured in the `CN=\u003cusername\u003e` format.\n\nAuthentication is optional. If authentication is not configured, no credentials are generated. ACLs and quotas set for the user are configured in the `\u003cusername\u003e` format suitable for SASL authentication.","type":"object","required":["type"],"properties":{"password":{"description":"Specify the password for the user. If not set, a new password is generated by the User Operator.","type":"object","required":["valueFrom"],"properties":{"valueFrom":{"description":"Secret from which the password should be read.","type":"object","properties":{"secretKeyRef":{"description":"Selects a key of a Secret in the resource's namespace.","type":"object","properties":{"key":{"type":"string"},"name":{"type":"string"},"optional":{"type":"boolean"}}}}}}},"type":{"description":"Authentication type.","type":"string","enum":["tls","tls-external","scram-sha-512"]}}},"authorization":{"description":"Authorization rules for this Kafka user.","type":"object","required":["acls","type"],"properties":{"acls":{"description":"List of ACL rules which should be applied to this user.","type":"array","items":{"type":"object","required":["resource"],"properties":{"host":{"description":"The host from which the action described in the ACL rule is allowed or denied.","type":"string"},"operation":{"description":"Operation which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.","type":"string","enum":["Read","Write","Create","Delete","Alter","Describe","ClusterAction","AlterConfigs","DescribeConfigs","IdempotentWrite","All"]},"operations":{"description":"List of operations which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.","type":"array","items":{"type":"string","enum":["Read","Write","Create","Delete","Alter","Describe","ClusterAction","AlterConfigs","DescribeConfigs","IdempotentWrite","All"]}},"resource":{"description":"Indicates the resource for which given ACL rule applies.","type":"object","required":["type"],"properties":{"name":{"description":"Name of resource for which given ACL rule applies. Can be combined with `patternType` field to use prefix pattern.","type":"string"},"patternType":{"description":"Describes the pattern used in the resource field. The supported types are `literal` and `prefix`. With `literal` pattern type, the resource field will be used as a definition of a full name. With `prefix` pattern type, the resource name will be used only as a prefix. Default value is `literal`.","type":"string","enum":["literal","prefix"]},"type":{"description":"Resource type. The available resource types are `topic`, `group`, `cluster`, and `transactionalId`.","type":"string","enum":["topic","group","cluster","transactionalId"]}}},"type":{"description":"The type of the rule. Currently the only supported type is `allow`. ACL rules with type `allow` are used to allow user to execute the specified operations. Default value is `allow`.","type":"string","enum":["allow","deny"]}}}},"type":{"description":"Authorization type. Currently the only supported type is `simple`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization.","type":"string","enum":["simple"]}}},"quotas":{"description":"Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.","type":"object","properties":{"consumerByteRate":{"description":"A quota on the maximum bytes per-second that each client group can fetch from a broker before the clients in the group are throttled. Defined on a per-broker basis.","type":"integer","minimum":0},"controllerMutationRate":{"description":"A quota on the rate at which mutations are accepted for the create topics request, the create partitions request and the delete topics request. The rate is accumulated by the number of partitions created or deleted.","type":"number","minimum":0},"producerByteRate":{"description":"A quota on the maximum bytes per-second that each client group can publish to a broker before the clients in the group are throttled. Defined on a per-broker basis.","type":"integer","minimum":0},"requestPercentage":{"description":"A quota on the maximum CPU utilization of each client group as a percentage of network and I/O threads.","type":"integer","minimum":0}}},"template":{"description":"Template to specify how Kafka User `Secrets` are generated.","type":"object","properties":{"secret":{"description":"Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.","type":"object","properties":{"metadata":{"description":"Metadata applied to the resource.","type":"object","properties":{"annotations":{"description":"Annotations added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true},"labels":{"description":"Labels added to the Kubernetes resource.","type":"object","x-kubernetes-preserve-unknown-fields":true}}}}}}}}},"status":{"description":"The status of the Kafka User.","type":"object","properties":{"conditions":{"description":"List of status conditions.","type":"array","items":{"type":"object","properties":{"lastTransitionTime":{"description":"Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.","type":"string"},"message":{"description":"Human-readable message indicating details about the condition's last transition.","type":"string"},"reason":{"description":"The reason for the condition's last transition (a single word in CamelCase).","type":"string"},"status":{"description":"The status of the condition, either True, False or Unknown.","type":"string"},"type":{"description":"The unique identifier of a condition, used to distinguish between other conditions in the resource.","type":"string"}}}},"observedGeneration":{"description":"The generation of the CRD that was last reconciled by the operator.","type":"integer"},"secret":{"description":"The name of `Secret` where the credentials are stored.","type":"string"},"username":{"description":"Username.","type":"string"}}}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaUser","version":"v1beta2"}]},"io.strimzi.kafka.v1beta2.KafkaUserList":{"description":"KafkaUserList is a list of KafkaUser","type":"object","required":["items"],"properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"items":{"description":"List of kafkausers. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md","type":"array","items":{"$ref":"#/components/schemas/io.strimzi.kafka.v1beta2.KafkaUser"}},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"description":"Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","allOf":[{"$ref":"#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"}]}},"x-kubernetes-group-version-kind":[{"group":"kafka.strimzi.io","kind":"KafkaUserList","version":"v1beta2"}]}}}}